<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实现拓展的方式：SPI 拦截调用</title>
    <link href="/2023/10/16/20231016-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9ASPI%20%E6%8B%A6%E6%88%AA%E8%B0%83%E7%94%A8/"/>
    <url>/2023/10/16/20231016-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9ASPI%20%E6%8B%A6%E6%88%AA%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-SPI"><a href="#1-SPI" class="headerlink" title="1. SPI"></a>1. SPI</h3><h4 id="1-1-什么是SPI机制"><a href="#1-1-什么是SPI机制" class="headerlink" title="1.1 什么是SPI机制"></a>1.1 什么是SPI机制</h4><p>​这个问题可以跟API比较起来解释。</p><table><thead><tr><th></th><th><strong>全称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>API</strong></td><td>application provider interface</td><td>“接口”位于“实现方”所在的“包”中</td></tr><tr><td><strong>SPI</strong></td><td>service provider interfase</td><td>“接口”位于“调用方”所在的“包”中</td></tr></tbody></table><p>​SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。</p><p><img src="/%5Cimg%5C20231016-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9ASPI%E3%80%81%E6%8B%A6%E6%88%AA%E8%B0%83%E7%94%A8-01.jpg" alt="Java SPI机制"></p><p>​当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF&#x2F;..的指定目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。</p><p>参考资料：Java常用机制 - SPI机制详解  <a href="https://pdai.tech/md/java/advanced/java-advanced-spi.html">https://pdai.tech/md/java/advanced/java-advanced-spi.html</a></p><h4 id="1-2-SPI的几种实现"><a href="#1-2-SPI的几种实现" class="headerlink" title="1.2 SPI的几种实现"></a>1.2 SPI的几种实现</h4><table><thead><tr><th></th><th><strong>核心类</strong></th><th><strong>文件方式</strong></th><th><strong>获取某个固定的实现</strong></th></tr></thead><tbody><tr><td>JDK SPI</td><td>ServiceLoader</td><td>每个扩展点单独一个文件</td><td>不支持，只能按顺序获取所有实现</td></tr><tr><td>Dubbo SPI</td><td>ExtensionLoader</td><td>每个扩展点单独一个文件</td><td>有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合Dubbo SPI的注解很方便</td></tr><tr><td>Spring SPI</td><td>SpringFactoriesLoader</td><td>所有的扩展点在一个文件</td><td>不支持，只能按顺序获取所有实现。但由于Spring Boot ClassLoader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展</td></tr></tbody></table><p>参考资料：JDK&#x2F;Dubbo&#x2F;Spring 三种 SPI 机制，谁更好？ <a href="https://developer.huawei.com/consumer/cn/forum/topic/0201545775459280256">https://developer.huawei.com/consumer/cn/forum/topic/0201545775459280256</a> </p><h4 id="1-3-简单的实现用例"><a href="#1-3-简单的实现用例" class="headerlink" title="1.3 简单的实现用例"></a>1.3 简单的实现用例</h4><h5 id="1-3-1-jdk-SPI实现举例"><a href="#1-3-1-jdk-SPI实现举例" class="headerlink" title="1.3.1 jdk SPI实现举例"></a>1.3.1 jdk SPI实现举例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Search</span> &#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">searchDoc</span><span class="hljs-params">(String keyword)</span>;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearch</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Search</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">searchDoc</span><span class="hljs-params">(String keyword)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;文件搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseSearch</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Search</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">searchDoc</span><span class="hljs-params">(String keyword)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;数据搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">src.main.com.channon.util.spi.javaSPI.DatabaseSearch<br>src.main.com.channon.util.spi.javaSPI.FileSearch<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">javaSPITest</span><span class="hljs-params">()</span>&#123;<br>    ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);<br>    Iterator&lt;Search&gt; iterator = s.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-type">Search</span> <span class="hljs-variable">search</span> <span class="hljs-operator">=</span>  iterator.next();<br>        search.searchDoc(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">数据搜索 hello world<br>文件搜索 hello world<br></code></pre></td></tr></table></figure><h5 id="1-3-2-dubbo-SPI实现举例"><a href="#1-3-2-dubbo-SPI实现举例" class="headerlink" title="1.3.2 dubbo SPI实现举例"></a>1.3.2 dubbo SPI实现举例</h5><p>​这里实现了一个带有包装的SPI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Robot</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimusPrime</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Robot</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, this is optimus prime.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BumbleBee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Robot</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, this is bumble bee.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RobotWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Robot</span>&#123;<br><br>    <span class="hljs-keyword">private</span> Robot robot;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RobotWrapper</span><span class="hljs-params">(Robot robot)</span>&#123;<br>        <span class="hljs-built_in">this</span>.robot = robot;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;包装方法开始&quot;</span>);<br>        robot.sayHello();<br>        System.out.println(<span class="hljs-string">&quot;包装方法结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">a = src.main.com.channon.util.dubbo.<span class="hljs-type">OptimusPrime</span><br><br><span class="hljs-variable">b</span> <span class="hljs-operator">=</span> src.main.com.channon.util.dubbo.BumbleBee<br><br>src.main.com.channon.util.dubbo.RobotWrapper<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">spiTest</span><span class="hljs-params">()</span>&#123;<br>    ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class);<br>    <span class="hljs-type">Robot</span> <span class="hljs-variable">optimus</span> <span class="hljs-operator">=</span> extensionLoader.getExtension(<span class="hljs-string">&quot;a&quot;</span>);<br>    <span class="hljs-type">Robot</span> <span class="hljs-variable">bumble</span> <span class="hljs-operator">=</span> extensionLoader.getExtension(<span class="hljs-string">&quot;b&quot;</span>);<br>    bumble.sayHello();<br>    optimus.sayHello();<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">……<br>包装方法开始<br>Hello, <span class="hljs-built_in">this</span> is bumble bee.<br>包装方法结束<br>包装方法开始<br>Hello, <span class="hljs-built_in">this</span> is optimus prime.<br>包装方法结束<br></code></pre></td></tr></table></figure><h4 id="1-4-SPI的应用举例"><a href="#1-4-SPI的应用举例" class="headerlink" title="1.4 SPI的应用举例"></a>1.4 SPI的应用举例</h4><h5 id="1-4-1-jdk-SPI的使用——JDBC-Driver"><a href="#1-4-1-jdk-SPI的使用——JDBC-Driver" class="headerlink" title="1.4.1 jdk SPI的使用——JDBC Driver"></a>1.4.1 jdk SPI的使用——JDBC Driver</h5><p>​在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName(“com.mysql.jdbc.Driver”)这句先加载数据库相关的驱动，然后再进行获取连接等的操作。<strong>而JDBC4.0之后不需要用Class.forName(“com.mysql.jdbc.Driver”)来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现</strong>。</p><h6 id="JDBC接口定义"><a href="#JDBC接口定义" class="headerlink" title="JDBC接口定义"></a>JDBC接口定义</h6><p>​首先在java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。</p><h6 id="mysql实现"><a href="#mysql实现" class="headerlink" title="mysql实现"></a>mysql实现</h6><p>​在mysql的jar包mysql-connector-java-6.0.6.jar中，可以找到META-INF&#x2F;services目录，该目录下会有一个名字为java.sql.Driver的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是针对Java中定义的接口的实现。</p><h6 id="postgresql实现"><a href="#postgresql实现" class="headerlink" title="postgresql实现"></a>postgresql实现</h6><p>​同样在postgresql的jar包postgresql-42.0.0.jar中，也可以找到同样的配置文件，文件内容是org.postgresql.Driver，这是postgresql对Java的java.sql.Driver的实现。</p><h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><p>​上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用Class.forName(“com.mysql.jdbc.Driver”)来加载驱动了，而是直接使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:xxxx://xxxx:xxxx/xxxx&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,username,password);<br>.....<br></code></pre></td></tr></table></figure><p>​这里并没有涉及到spi的使用，接着看下面的解析。</p><h6 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h6><p>​上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码Class.forName(“com.mysql.jdbc.Driver”)！</p><p>​上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在DriverManager中，DriverManager是Java中的实现，用来获取数据库连接，在DriverManager中有一个静态代码块如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadInitialDrivers</span><span class="hljs-params">()</span> &#123;<br>    String drivers;<br>    <span class="hljs-keyword">try</span> &#123;<br>        drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;String&gt;() &#123;<br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        drivers = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// If the driver is packaged as a Service Provider, load it.</span><br>    <span class="hljs-comment">// Get all the drivers through the classloader</span><br>    <span class="hljs-comment">// exposed as a java.sql.Driver.class service.</span><br>    <span class="hljs-comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span><br><br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br><br>            <span class="hljs-comment">/* Load these drivers, so that they can be instantiated.</span><br><span class="hljs-comment">                 * It may be the case that the driver class may not be there</span><br><span class="hljs-comment">                 * i.e. there may be a packaged driver with the service class</span><br><span class="hljs-comment">                 * as implementation of java.sql.Driver but the actual class</span><br><span class="hljs-comment">                 * may be missing. In that case a java.util.ServiceConfigurationError</span><br><span class="hljs-comment">                 * will be thrown at runtime by the VM trying to locate</span><br><span class="hljs-comment">                 * and load the service.</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * Adding a try catch block to catch those runtime errors</span><br><span class="hljs-comment">                 * if driver not available in classpath but it&#x27;s</span><br><span class="hljs-comment">                 * packaged as service and that service is there in classpath.</span><br><span class="hljs-comment">                 */</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                    driversIterator.next();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>                <span class="hljs-comment">// Do nothing</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);<br><br>    println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>    <span class="hljs-keyword">if</span> (drivers == <span class="hljs-literal">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>    println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>    <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println(<span class="hljs-string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);<br>            Class.forName(aDriver, <span class="hljs-literal">true</span>,<br>                          ClassLoader.getSystemClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            println(<span class="hljs-string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​上面的代码主要步骤是：</p><ul><li>从系统变量中获取有关驱动的定义。</li><li>使用SPI来获取驱动的实现。</li><li>遍历使用SPI获取到的具体实现，实例化各个实现类。</li><li>根据第一步获取到的驱动列表来实例化具体实现类。</li></ul><p>​我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br></code></pre></td></tr></table></figure><p>​这里没有去META-INF&#x2F;services目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。</p><p>​接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取迭代器</span><br>Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br><span class="hljs-comment">//遍历所有的驱动实现</span><br><span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>    driversIterator.next();<br>&#125;<br></code></pre></td></tr></table></figure><p>​在遍历的时候，首先调用driversIterator.hasNext()方法，这里会搜索classpath下以及jar包中所有的META-INF&#x2F;services目录下的java.sql.Driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。</p><p>​然后是调用driversIterator.next();方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。</p><p>参考资料：Java常用机制 - SPI机制详解 <a href="https://pdai.tech/md/java/advanced/java-advanced-spi.html">https://pdai.tech/md/java/advanced/java-advanced-spi.html</a> </p><h5 id="1-4-2-dubbo-SPI的使用——dubbo的拓展点"><a href="#1-4-2-dubbo-SPI的使用——dubbo的拓展点" class="headerlink" title="1.4.2 dubbo SPI的使用——dubbo的拓展点"></a>1.4.2 dubbo SPI的使用——dubbo的拓展点</h5><p>​dubbo在本身的服务框架中插入了多个拓展点，如下图</p><p><img src="/img/20231016-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9ASPI%E3%80%81%E6%8B%A6%E6%88%AA%E8%B0%83%E7%94%A8-02.jpg" alt="img"></p><p>​依照说明定义相应的SPI实现类，即可实现功能拓展。dubbo SPI的工作过程如下：</p><p><img src="/img/20231016-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9ASPI%E3%80%81%E6%8B%A6%E6%88%AA%E8%B0%83%E7%94%A8-03.jpg" alt="img"></p><h6 id="ExtensionLoader源码解析"><a href="#ExtensionLoader源码解析" class="headerlink" title="ExtensionLoader源码解析"></a>ExtensionLoader源码解析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getExtension</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> wrap)</span> &#123;<br>    checkDestroyed();<br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension name == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(name)) &#123;<br>        <span class="hljs-keyword">return</span> getDefaultExtension();<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> name;<br>    <span class="hljs-keyword">if</span> (!wrap) &#123;<br>        cacheKey += <span class="hljs-string">&quot;_origin&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(cacheKey);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> holder.get();<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (holder) &#123;<br>            instance = holder.get();<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                instance = createExtension(name, wrap);<br>                holder.set(instance);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>​getExtension是ExtensionLoader的入口，这段代码比较简单，查询缓存，缓存不命中就创建拓展。接下来看创建方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">createExtension</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> wrap)</span> &#123;<br>    Class&lt;?&gt; clazz = getExtensionClasses().get(name);<br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span> || unacceptableExceptions.contains(name)) &#123;<br>        <span class="hljs-keyword">throw</span> findException(name);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (T) extensionInstances.get(clazz);<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            extensionInstances.putIfAbsent(clazz, createExtensionInstance(clazz));<br>            instance = (T) extensionInstances.get(clazz);<br>            instance = postProcessBeforeInitialization(instance, name);<br>            injectExtension(instance);<br>            instance = postProcessAfterInitialization(instance, name);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (wrap) &#123;<br>            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">if</span> (cachedWrapperClasses != <span class="hljs-literal">null</span>) &#123;<br>                wrapperClassesList.addAll(cachedWrapperClasses);<br>                wrapperClassesList.sort(WrapperComparator.COMPARATOR);<br>                Collections.reverse(wrapperClassesList);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;<br>                <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;<br>                    <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> wrapperClass.getAnnotation(Wrapper.class);<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> (wrapper == <span class="hljs-literal">null</span>) ||<br>                        ((ArrayUtils.isEmpty(wrapper.matches()) || ArrayUtils.contains(wrapper.matches(), name)) &amp;&amp;<br>                            !ArrayUtils.contains(wrapper.mismatches(), name));<br>                    <span class="hljs-keyword">if</span> (match) &#123;<br>                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));<br>                        instance = postProcessAfterInitialization(instance, name);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Warning: After an instance of Lifecycle is wrapped by cachedWrapperClasses, it may not still be Lifecycle instance, this application may not invoke the lifecycle.initialize hook.</span><br>        initExtension(instance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Extension instance (name: &quot;</span> + name + <span class="hljs-string">&quot;, class: &quot;</span> +<br>            type + <span class="hljs-string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：</p><ol><li>通过 getExtensionClasses 获取所有的拓展类</li><li>通过反射创建拓展对象</li><li>向拓展对象中注入依赖</li><li>将拓展对象包裹在相应的 Wrapper 对象中</li><li>初始化拓展对象</li></ol><p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现，留待后面分析。</p><p>参考资料：Dubbo SPI 概述 <a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/overview/">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/overview/</a> </p><h3 id="2-拦截调用实现拓展——Mybatis的Interceptor"><a href="#2-拦截调用实现拓展——Mybatis的Interceptor" class="headerlink" title="2. 拦截调用实现拓展——Mybatis的Interceptor"></a>2. 拦截调用实现拓展——Mybatis的Interceptor</h3><p>​网上找了一下mybatis执行流程的图：</p><p><img src="/img/20231016-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9ASPI%E3%80%81%E6%8B%A6%E6%88%AA%E8%B0%83%E7%94%A8-04.jpg" alt="MyBatis层次结构"></p><p>​默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>​通过实现这些插件，就可以实现对最后执行的sql的修改。</p><h4 id="2-1-举例：PageHelper"><a href="#2-1-举例：PageHelper" class="headerlink" title="2.1 举例：PageHelper"></a>2.1 举例：PageHelper</h4><p>​PageHelper的核心类就是interceptor的一个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(</span><br><span class="hljs-meta">    type = Executor.class,</span><br><span class="hljs-meta">    method = &quot;query&quot;,</span><br><span class="hljs-meta">    args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="hljs-meta">), @Signature(</span><br><span class="hljs-meta">    type = Executor.class,</span><br><span class="hljs-meta">    method = &quot;query&quot;,</span><br><span class="hljs-meta">    args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;</span><br><span class="hljs-meta">)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    ……<br>&#125;<br><span class="hljs-meta">@Intercepts(&#123;@Signature(</span><br><span class="hljs-meta">    type = Executor.class,</span><br><span class="hljs-meta">    method = &quot;query&quot;,</span><br><span class="hljs-meta">    args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="hljs-meta">), @Signature(</span><br><span class="hljs-meta">    type = Executor.class,</span><br><span class="hljs-meta">    method = &quot;query&quot;,</span><br><span class="hljs-meta">    args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;</span><br><span class="hljs-meta">)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">QueryInterceptor</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​上面的注解可以配置它相应的拦截点，如这个拦截点位于Executor。</p><h4 id="2-2-举例：sharding-sphere"><a href="#2-2-举例：sharding-sphere" class="headerlink" title="2.2 举例：sharding sphere"></a>2.2 举例：sharding sphere</h4><p>​它的核心类是ShardingSelectInterceptor和ShardingInsertInterceptor。</p><p>​（未找到代码，暂时留空）</p><h4 id="2-3-Mybatis的Interceptor是如何实现的"><a href="#2-3-Mybatis的Interceptor是如何实现的" class="headerlink" title="2.3 Mybatis的Interceptor是如何实现的"></a>2.3 Mybatis的Interceptor是如何实现的</h4><p>​在mybatis的Configuration类里实现了插入handler的代码，在上层调用时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ParameterHandler <span class="hljs-title function_">newParameterHandler</span><span class="hljs-params">(MappedStatement mappedStatement, Object parameterObject,</span><br><span class="hljs-params">    BoundSql boundSql)</span> &#123;<br>  <span class="hljs-type">ParameterHandler</span> <span class="hljs-variable">parameterHandler</span> <span class="hljs-operator">=</span> mappedStatement.getLang().createParameterHandler(mappedStatement,<br>      parameterObject, boundSql);<br>  <span class="hljs-keyword">return</span> (ParameterHandler) interceptorChain.pluginAll(parameterHandler);<br>&#125;<br><br><span class="hljs-keyword">public</span> ResultSetHandler <span class="hljs-title function_">newResultSetHandler</span><span class="hljs-params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds,</span><br><span class="hljs-params">    ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;<br>  <span class="hljs-type">ResultSetHandler</span> <span class="hljs-variable">resultSetHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResultSetHandler</span>(executor, mappedStatement, parameterHandler,<br>      resultHandler, boundSql, rowBounds);<br>  <span class="hljs-keyword">return</span> (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);<br>&#125;<br><br><span class="hljs-keyword">public</span> StatementHandler <span class="hljs-title function_">newStatementHandler</span><span class="hljs-params">(Executor executor, MappedStatement mappedStatement,</span><br><span class="hljs-params">    Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;<br>  <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">statementHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoutingStatementHandler</span>(executor, mappedStatement, parameterObject,<br>      rowBounds, resultHandler, boundSql);<br>  <span class="hljs-keyword">return</span> (StatementHandler) interceptorChain.pluginAll(statementHandler);<br>&#125;<br><br><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">newExecutor</span><span class="hljs-params">(Transaction transaction)</span> &#123;<br>  <span class="hljs-keyword">return</span> newExecutor(transaction, defaultExecutorType);<br>&#125;<br><br><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">newExecutor</span><span class="hljs-params">(Transaction transaction, ExecutorType executorType)</span> &#123;<br>  executorType = executorType == <span class="hljs-literal">null</span> ? defaultExecutorType : executorType;<br>  Executor executor;<br>  <span class="hljs-keyword">if</span> (ExecutorType.BATCH == executorType) &#123;<br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ExecutorType.REUSE == executorType) &#123;<br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReuseExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (cacheEnabled) &#123;<br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingExecutor</span>(executor);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (Executor) interceptorChain.pluginAll(executor);<br>&#125;<br></code></pre></td></tr></table></figure><p>​上面代码功能是：对statementHandler 插入所有的Interceptor以便进行拦截，InterceptorChain里保存了所有的拦截器，它在Configuration 对象被构造出来的时候创建。</p><p>参考资料：MyBatis源码剖析 - MyBatis 插件之拦截器（Interceptor）实现原理  <a href="https://blog.csdn.net/top_code/article/details/55657776">https://blog.csdn.net/top_code/article/details/55657776</a> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些PostgreSQL跟MySQL的细微差别</title>
    <link href="/2023/10/11/20231011-%E4%B8%80%E4%BA%9BPostgreSQL%E8%B7%9FMySQL%E7%9A%84%E7%BB%86%E5%BE%AE%E5%B7%AE%E5%88%AB/"/>
    <url>/2023/10/11/20231011-%E4%B8%80%E4%BA%9BPostgreSQL%E8%B7%9FMySQL%E7%9A%84%E7%BB%86%E5%BE%AE%E5%B7%AE%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="一些PostgreSQL跟MySQL的细微差别"><a href="#一些PostgreSQL跟MySQL的细微差别" class="headerlink" title="一些PostgreSQL跟MySQL的细微差别"></a>一些PostgreSQL跟MySQL的细微差别</h3><h3 id="1-PostgreSQL和MySQL的MVCC"><a href="#1-PostgreSQL和MySQL的MVCC" class="headerlink" title="1. PostgreSQL和MySQL的MVCC"></a>1. PostgreSQL和MySQL的MVCC</h3><p>当同一个数据被两个事务写的时候，MySQL（Innodb）的默认实现是使用悲观锁行锁，锁住当前行，禁止其他事务读写。而PostgreSQL使用了MVCC，也就是记录了数据的版本号，当事务A写数据时，事务B仍可读到旧版本的数据。</p><h4 id="1-1-postgres-mvcc-一个事务读，一个事务写"><a href="#1-1-postgres-mvcc-一个事务读，一个事务写" class="headerlink" title="1.1. postgres mvcc 一个事务读，一个事务写"></a>1.1. postgres mvcc 一个事务读，一个事务写</h4><p>A事务读取数据，获取自己的快照</p><p>B事务读取数据</p><p>A事务修改完成，提交，更新数据版本号</p><h4 id="1-2-postgres-mvcc-两个事务写"><a href="#1-2-postgres-mvcc-两个事务写" class="headerlink" title="1.2. postgres mvcc 两个事务写"></a>1.2. postgres mvcc 两个事务写</h4><p>乐观锁，会等到第一个事务执行完再执行第二个数据。</p><p>A事务读取数据，获取自己的快照</p><p>B事务读取数据，获取自己的快照</p><p>A事务修改完成，提交，更新数据版本号</p><p>B事务修改完成，提交，发现自己版本号较低，重新获取快照修改</p><p>B事务修改完成，提交，更新数据版本号</p><h4 id="1-3-怎么启用mysql的mvcc？"><a href="#1-3-怎么启用mysql的mvcc？" class="headerlink" title="1.3. 怎么启用mysql的mvcc？"></a>1.3. 怎么启用mysql的mvcc？</h4><p>​mysql5.6以上版本才支持，RR隔离级别才支持</p><h4 id="1-4-mvcc跟行锁有什么区别？"><a href="#1-4-mvcc跟行锁有什么区别？" class="headerlink" title="1.4. mvcc跟行锁有什么区别？"></a>1.4. mvcc跟行锁有什么区别？</h4><p>​两个请求同时抵达数据库，每个请求是一个独立事务。A请求修改数据，B请求查询数据，A请求先到。</p><p>​在MySQL的机制下，A事务会锁住这一行数据，B无法读取。等到A释放行锁后，B才可以读取数据。</p><p>​在MVCC机制下，A会新增一行记录，不锁数据。B可以无阻塞地查到旧版本的数据。</p><h3 id="2-PostgreSQL和MySQL的索引"><a href="#2-PostgreSQL和MySQL的索引" class="headerlink" title="2. PostgreSQL和MySQL的索引"></a>2. PostgreSQL和MySQL的索引</h3><p>​mysql只能在整张表上建立索引，但pg可以在某些列上建立索引。</p><p>​postgres还支持更多的索引类型。</p><p>​mysql仅支持B树索引和hash索引，postgres还支持GiST、SP-GiST等。</p><p>​mysql仅支持整张表建立索引，pg可以建立部分索引、表达式索引、多列索引。</p><p>​postgres支持并发索引。</p><h3 id="3-PostgreSQL和MySQL对SQL的优化"><a href="#3-PostgreSQL和MySQL对SQL的优化" class="headerlink" title="3. PostgreSQL和MySQL对SQL的优化"></a>3. PostgreSQL和MySQL对SQL的优化</h3><h4 id="3-1-查询计划优化"><a href="#3-1-查询计划优化" class="headerlink" title="3.1. 查询计划优化"></a>3.1. 查询计划优化</h4><p>​PostgreSQL的优化器会考虑表之间的统计相关信息,调整Join顺序以减少记录数。MySQL的优化器基本按照Join语句顺序处理。</p><p>​PostgreSQL会估算不同的索引在过滤记录数方面的效果,选用最有效的索引。MySQL的选择较简单。</p><h4 id="3-2-统计信息"><a href="#3-2-统计信息" class="headerlink" title="3.2. 统计信息"></a>3.2. 统计信息</h4><p>​PostgreSQL自动收集并利用各种统计信息进行查询优化,包括列相关性、distinct值比例等。MySQL只有基础的表级统计信息。</p><h3 id="4-PostgreSQL的堆表和InnoDB中的索引表"><a href="#4-PostgreSQL的堆表和InnoDB中的索引表" class="headerlink" title="4. PostgreSQL的堆表和InnoDB中的索引表"></a>4. PostgreSQL的堆表和InnoDB中的索引表</h3><p>​postgres是堆表，追加写入，主键可以不连续。innodb索引表，涉及页分裂和页合并，主键最好连续。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中的软引用和它的测试</title>
    <link href="/2023/09/07/20230907-Java%E4%B8%AD%E7%9A%84%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%AE%83%E7%9A%84%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/09/07/20230907-Java%E4%B8%AD%E7%9A%84%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%AE%83%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Java中的软引用和它的测试"><a href="#Java中的软引用和它的测试" class="headerlink" title="Java中的软引用和它的测试"></a>Java中的软引用和它的测试</h3><h4 id="软引用介绍"><a href="#软引用介绍" class="headerlink" title="软引用介绍"></a>软引用介绍</h4><h3 id="软引用和它的测试"><a href="#软引用和它的测试" class="headerlink" title="软引用和它的测试"></a>软引用和它的测试</h3><p>​将被回收的困难程度排序，应该是强引用&gt;软引用&gt;弱引用。对比软引用和对引用，软引用的回收时间是不可预测的，它仅在内存紧张的GC进行回收。而弱引用会在下一次GC时被回收。</p><h4 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h4><p>​为了验证它的回收，我们可以创建一个持有SoftReference的list，不断往里塞大对象，不断触发GC，查看结果。注，内存紧张回收后，该对象被回收，但指向该对象的指针没有被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;<span class="hljs-type">byte</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;first data in list: &quot;</span> + list.get(<span class="hljs-number">0</span>).get());<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSoftReference</span><span class="hljs-params">()</span>&#123;<br>    ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;<span class="hljs-type">byte</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>]));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>        () -&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;soft reference list size: &quot;</span> + list.size());<br>                System.out.println(<span class="hljs-string">&quot;first data in list: &quot;</span> + list.get(<span class="hljs-number">0</span>).get());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">300L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    ).start();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.currentThread().join();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        System.exit(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM参数如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">-<span class="hljs-keyword">ea</span> -<span class="hljs-keyword">verbose</span>:gc -Xms4m -Xmx4m -Xmn2m <br></code></pre></td></tr></table></figure><h4 id="分析测试结果"><a href="#分析测试结果" class="headerlink" title="分析测试结果"></a>分析测试结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;first data in list: &quot;</span> + list.get(<span class="hljs-number">0</span>).get());<br></code></pre></td></tr></table></figure><p>​上面语句不会报空指针异常，这说明GC回收了软引用对象后，并没有回收软引用变量本身，如果希望软引用变量被回收，最好将它添加到reference queue再手动回收。</p><p>打印日志如下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3039</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2586</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0083289</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3039</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2610</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0100043</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">soft</span> <span class="hljs-variable">reference</span> <span class="hljs-variable">list</span> <span class="hljs-variable">size</span><span class="hljs-operator">:</span> <span class="hljs-number">1</span><br><span class="hljs-variable">first</span> <span class="hljs-variable">data</span> <span class="hljs-variable">in</span> <span class="hljs-variable">list</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">B</span><span class="hljs-operator">@</span><span class="hljs-number">2781</span><span class="hljs-variable">fef4</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3035</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2732</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0090069</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3039</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2896</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0137084</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3029</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3007</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0065464</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3021</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2986</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0062080</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3029</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3010</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0056912</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3028</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3010</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0059427</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3010</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2704</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0124300</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">soft</span> <span class="hljs-variable">reference</span> <span class="hljs-variable">list</span> <span class="hljs-variable">size</span><span class="hljs-operator">:</span> <span class="hljs-number">1</span><br><span class="hljs-variable">first</span> <span class="hljs-variable">data</span> <span class="hljs-variable">in</span> <span class="hljs-variable">list</span><span class="hljs-operator">:</span> <span class="hljs-variable">null</span><br></code></pre></td></tr></table></figure><p>​通过这段代码我们可以观察到，在GC的初始几次循环中尽管发生了垃圾回收，但是软引用对象还没有被回收。这是因为JVM认为内存空间还充足,可以继续保留软引用对象。但是随着程序运行，内存空间逐渐紧张，在某一次GC过程中，JVM终于决定回收软引用对象以释放更多内存。此时我们打印软引用所引用的对象,其值为null。这表示软引用对象已经被回收了。</p><p>​但需要注意的是，原本指向这个软引用对象的软引用变量list本身还存在，它仍然保持对这个已经被回收对象的引用，只是这个引用现在无效了，如下图。如果程序不及时清理这种无效引用,可能会渐渐占用较多内存。</p><p><img src="/img/230907-%E8%BD%AF%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%9B%9E%E6%94%B6.jpg" alt="230907-软引用变量回收"></p><h4 id="软引用变量的回收"><a href="#软引用变量的回收" class="headerlink" title="软引用变量的回收"></a>软引用变量的回收</h4><p>​为了避免上述情况，我们可以主动回收软引用变量。</p><h5 id="放入引用队列进行回收"><a href="#放入引用队列进行回收" class="headerlink" title="放入引用队列进行回收"></a>放入引用队列进行回收</h5><p>将软引用变量放入引用队列里，在回收的时候手动释放它。将创建对象并塞入对象的代码改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br> <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <br>     list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;<span class="hljs-type">byte</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>], referenceQueue));<br> &#125;<br></code></pre></td></tr></table></figure><p>​    使用另一个线程不断扫描referenceQueue，当软引用对象被回收时，软引用变量就会被放入referenceQueue中，我们可以通过手动把它设置为null，或者从list中移除它来回收。</p><h5 id="WeakHashMap进行回收"><a href="#WeakHashMap进行回收" class="headerlink" title="WeakHashMap进行回收"></a>WeakHashMap进行回收</h5><p>​另外，也可以使用WeakHashMap来储存，储存的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakHashMap&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;, <span class="hljs-type">byte</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>]);<br>    map.put(obj, obj.get());<br>    System.out.println(<span class="hljs-string">&quot;add data in map.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>命令行输出</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">[Full GC (Ergonomics)  3014K-&gt;2907K(3584K), 0.0063295 secs]<br>soft reference map size: 2<br>first data in map: java.lang.ref.SoftReference@4c67258e=[B@58a828a3<br>[Full GC (Ergonomics)  2912K-&gt;2807K(3584K), 0.0058464 secs]<br>add data in map.<br>[Full GC (Ergonomics)  2913K-&gt;2807K(3584K), 0.0080876 secs]<br>add data in map.<br>[Full GC (Ergonomics)  2912K-&gt;2807K(3584K), 0.0067576 secs]<br>add data in map.<br>soft reference map size: 1<br>first data in map: java.lang.ref.SoftReference@2b0d69c0=[B@1daaadd2<br></code></pre></td></tr></table></figure><p>​分析日志，可以看到，最开始map中已经有两个对象，后面也在不断往map中插入数据。但经过几轮回收后，map size变为了1。这说明，JVM中间经过了一次内存紧张的回收，将我们建立的软引用变量回收了，而在下一次回收中，weakHashMap识别到它的value被回收，于是主动删除了这个键值对。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>写一个用zk监听变化的Kafka Consumer</title>
    <link href="/2023/09/02/20230903-%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%A8zk%E7%9B%91%E5%90%AC%E5%8F%98%E5%8C%96%E7%9A%84kafkaconsumer/"/>
    <url>/2023/09/02/20230903-%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%A8zk%E7%9B%91%E5%90%AC%E5%8F%98%E5%8C%96%E7%9A%84kafkaconsumer/</url>
    
    <content type="html"><![CDATA[<p>功能简介：</p><ol><li>写一个kafka consumer manager类</li><li>实现一个具体的kafka consumer</li><li>注册zk监听器，监听zk变化修改consumer订阅的topic</li></ol><h3 id="1-写一个kafka-consumer-manager类"><a href="#1-写一个kafka-consumer-manager类" class="headerlink" title="1. 写一个kafka consumer manager类"></a>1. 写一个kafka consumer manager类</h3><ul><li>kafka consumer manager类，用于管理kafka consumer</li><li>找到每个消费者，订阅各自主题</li><li>将任务交给线程池处理</li><li>设置关闭函数</li></ul><h4 id="1-1-kafka-consumer-manager类，用于管理kafka-consumer"><a href="#1-1-kafka-consumer-manager类，用于管理kafka-consumer" class="headerlink" title="1.1 kafka consumer manager类，用于管理kafka consumer"></a>1.1 kafka consumer manager类，用于管理kafka consumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ConcurrentMap&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; kafkaConsumers;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(kafkaConsumers == <span class="hljs-literal">null</span>)&#123;<br>        kafkaConsumers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Reflections</span> <span class="hljs-variable">reflections</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reflections</span>(<span class="hljs-string">&quot;src.main.com.channon.util&quot;</span>);<br>        Set&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KafkaConsumer</span>&gt;&gt; subTypes = reflections.getSubTypesOf(KafkaConsumer.class);<br>        subTypes.forEach(clazz -&gt; &#123;<br>        <span class="hljs-type">KafkaConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> clazz.getConstructor(Properties.class).newInstance(kafkaConfig.consumerConfigs());<br>            <span class="hljs-comment">// 消费者订阅主题</span><br>            <span class="hljs-comment">// 消费者拉取消息代码交给线程池</span><br>            <span class="hljs-comment">// 设置关闭处理</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建了一个KafkaConsumerManager类，通过反射获取所有继承了KafkaConsumer的子类，再作处理。</p><h4 id="1-2-消费者订阅各自主题"><a href="#1-2-消费者订阅各自主题" class="headerlink" title="1.2 消费者订阅各自主题"></a>1.2 消费者订阅各自主题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribeTopic</span><span class="hljs-params">(Class clazz, KafkaConsumer consumer)</span>&#123;<br>    Set&lt;Map.Entry&lt;String, String&gt;&gt; listener = zookeeperConfig.pathHandlerMap.entrySet();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">configTopic</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;String, String&gt; entry:listener)&#123;<br>        <span class="hljs-keyword">if</span>(listener.equals(clazz.getName()))&#123;<br>            configTopic = <span class="hljs-literal">true</span>;<br>            consumer.subscribe(Collections.singleton(entry.getKey()));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!configTopic)&#123;<br>        consumer.subscribe(Collections.singleton(kafkaConfig.topic));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    从配置中读取每个消费者对应的主题，如果有单独配置就读取单独配置，如果没有就读取通用配置。这里配置获取方式各有不同，大家可以选择各自的实现方式。唯一需要注意的是， 配置获取的时间应该先于manager init代码运行的时间。</p><h4 id="1-3-将任务交给线程池处理"><a href="#1-3-将任务交给线程池处理" class="headerlink" title="1.3 将任务交给线程池处理"></a>1.3 将任务交给线程池处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">kafkaConsumerPool.addTask(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (subscribeLock) &#123;<br>                    <span class="hljs-type">ConsumerRecords</span> <span class="hljs-variable">records</span> <span class="hljs-operator">=</span> consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (WakeupException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            consumer.close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>​    设置时间，每个消费者隔一段时间会从kafka里拉取消息，consumer交由线程池管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaConsumerPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService executorService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    KafkaConsumerManager kafkaConsumerManager;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(Runnable task)</span>&#123;<br>        executorService.submit(task);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>        Map&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; consumers = kafkaConsumerManager.kafkaConsumers();<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; entry : consumers.entrySet())&#123;<br>            entry.getValue().wakeup();<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面一段是线程池的代码。需要注意的是，kafka consumer是需要一直在后台运行的，所以最好是设置一个固定线程数的线程池，线程数 &#x3D; 消费者数。</p><p>​    线程池关闭的时候会获取所有的消费者，并调用wakeup()。</p><h5 id="为什么关闭消费者时调用的是wakeup-而不是close-？"><a href="#为什么关闭消费者时调用的是wakeup-而不是close-？" class="headerlink" title="为什么关闭消费者时调用的是wakeup()而不是close()？"></a>为什么关闭消费者时调用的是wakeup()而不是close()？</h5><p>​    wakeup是更轻量也更安全的方法。</p><p>​    轻量：它会将client里的wakeup设置为true，kafka在下一次poll数据时就会读取到wakeup设置，并抛出一个WakeUpException。调用线程更改完变量即可退出，无需等待kafka consumer彻底关闭。</p><p>​    安全： wakeup会在下次poll之前抛出异常，而close可能打断poll的过程，使得缓存区的该批数据丢失，这批数据可能处于未处理、处理中、已处理未提交位移的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// KafkaConsumer源码</span><br><span class="hljs-keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Timer timer, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> includeMetadataInTimeout)</span> &#123;<br>        acquireAndEnsureOpen();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ......<br>            &#125;<br><br>            <span class="hljs-keyword">do</span> &#123;<br>                client.maybeTriggerWakeup(); <span class="hljs-comment">// wakeup会在这里抛出异常</span><br><br>                <span class="hljs-keyword">final</span> Fetch&lt;K, V&gt; fetch = pollForFetches(timer);<br>                <span class="hljs-keyword">if</span> (!fetch.isEmpty()) &#123;<br>                    ......<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.interceptors.onConsume(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsumerRecords</span>&lt;&gt;(fetch.records()));<br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (timer.notExpired());<br><br>            <span class="hljs-keyword">return</span> ConsumerRecords.empty();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            release();<br>            <span class="hljs-built_in">this</span>.kafkaConsumerMetrics.recordPollEnd(timer.currentTimeMs());<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-4-设置关闭函数"><a href="#1-4-设置关闭函数" class="headerlink" title="1.4 设置关闭函数"></a>1.4 设置关闭函数</h4><p>在zookeeper util中，我们将关闭函数写在Runtime预留的callback函数里，但这里使用了线程池，所以在线程池中处理关闭即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>    Map&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; consumers = kafkaConsumerManager.kafkaConsumers();<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; entry : consumers.entrySet())&#123;<br>        entry.getValue().wakeup();<br>    &#125;<br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-实现一个具体的Kafka-Consumer"><a href="#2-实现一个具体的Kafka-Consumer" class="headerlink" title="2. 实现一个具体的Kafka Consumer"></a>2. 实现一个具体的Kafka Consumer</h3><p>​    子类继承KafkaConsumer即可。对于我们需要的操作，可以通过重写poll函数来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumerRecords&lt;String, Object&gt; <span class="hljs-title function_">poll</span><span class="hljs-params">(Duration timeout)</span> &#123;<br><br>    <span class="hljs-comment">// call KafkaConsumer.poll() to get messages</span><br>    ConsumerRecords&lt;String, Object&gt; records = <span class="hljs-built_in">super</span>.poll(timeout);<br><br>    <span class="hljs-comment">// iterate records, print each message</span><br>    <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, Object&gt; record : records) &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Consumed by %s, topic = %s, partition = %d, offset = %d, key = %s, value = %s \n&quot;</span>,<br>                <span class="hljs-built_in">this</span>.getClass().getName(), record.topic(), record.partition(), record.offset(), record.key(), record.value());<br>    &#125;<br><br>    <span class="hljs-comment">// return records to user</span><br>    <span class="hljs-keyword">return</span> records;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上文先调用父类的poll函数拉取消息，然后执行我们期望的操作——打印信息，最后返回。</p><p>​    之前提到的close可能随时打断这里的任何操作，如执行完了super.poll，但还没有处理，就关闭了。这就会造成数据丢失。</p><h3 id="3-注册zk监听器，监听zk变化修改consumer订阅的topic"><a href="#3-注册zk监听器，监听zk变化修改consumer订阅的topic" class="headerlink" title="3. 注册zk监听器，监听zk变化修改consumer订阅的topic"></a>3. 注册zk监听器，监听zk变化修改consumer订阅的topic</h3><ul><li>不建议的操作</li><li>zk监听器实现</li><li>并发问题</li></ul><h4 id="3-1-不建议的操作"><a href="#3-1-不建议的操作" class="headerlink" title="3.1 不建议的操作"></a>3.1 不建议的操作</h4><p>我在几次尝试中发现，实时修改kafka consumer订阅的topic是一个非常不好的操作。</p><ol><li><p>kafka重平衡消费者导致信息丢失。consumer修改topic对于kafka是个消费者下线再上线的过程，这就回到了经典的kafka重平衡导致数据丢失问题。</p></li><li><p>kakfa consumer不是并发安全的实现。实时修改kafka consumer会遇到非常难处理的并发冲突，如果需要绝对安全又需要加锁，这会拖慢consumer的执行。</p><p>另外，kafka consumer检查到并发冲突后会抛出异常ConcurrentModificationException，需要妥善处理。</p></li></ol><p>​    我在查找网上方案的时候发现大家有两种实现方法，一种是检测到topic变更，直接close消费者再新建，另一种就是加锁。我选择了加锁实现。</p><h4 id="3-2-zk监听器实现"><a href="#3-2-zk监听器实现" class="headerlink" title="3.2 zk监听器实现"></a>3.2 zk监听器实现</h4><p>​    我们把kafka的topic配置到zookeeper上，写了一个zk listener，当zk node数据变更时就调用kafka consumer变更topic。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaPrintTopicListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IZkDataListener</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span>&#123;<br>        KafkaConsumerManager manager= ApplicationContextUtil.getBean(KafkaConsumerManager.class);<br>        <span class="hljs-type">KafkaConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> manager.kafkaConsumers().get(PrintConsumer.class.getName());<br>        <span class="hljs-keyword">synchronized</span> (subscribeLock)&#123;<br>            consumer.unsubscribe();<br>            consumer.subscribe(Collections.singleton(data.toString()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​     需要注意的是，这个类作为pojo类，需要使用到bean类KafkaConsumerManager，这涉及bean注入的问题。我在这里选择的实现是，创建一个ApplicationContextUtil，使得程序可以在任意地方通过这个Util获取Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextUtil</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext context;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ApplicationContextUtil</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>        ApplicationContextUtil.context = context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApplicationContext <span class="hljs-title function_">getApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getBean(beanClass);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-并发问题"><a href="#3-3-并发问题" class="headerlink" title="3.3 并发问题"></a>3.3 并发问题</h4><p>​    KafkaConsumerManager、KafkaPrintTopicListener和线程池都会对consumer进行更改，而consumer本身是线程不安全的，这里的访问会报错。我的解决方案是，在consumer类中创建一个Object类作为锁对象，对三个地方都加锁。</p><p>​    但是这不是一个优良的实现。如果在修改topic时，线程池的poll操作被阻塞，它就没法完成“定时拉取”的任务了。</p><p>​    另外，解决这个并发冲突的过程也是很有意思的过程。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">如果给两个调用共享变量的地方分别加锁,还是存在并发冲突的可能,原因可能有:<br>1. 两个地方加的锁对象不一样,需要使用同一对象锁才能起到互斥的效果。  <br>  check: 打印输出或日志检查,在加锁的地方打印出锁对象的引用,确认是否是同一个对象。引用地址相同，所以是同一个对象。<br>2. 加锁的范围不够,需要扩大锁的范围,直到包含所有访问共享变量的语句。<br>  check: 扩大到不能再大了……还是不行<br>3. 存在死锁情况,一个线程获取锁A等待锁B,另一个线程获取锁B等待锁A,导致互相等待。<br>  check: 应该不是<br>4. 有其它线程没有加锁也访问了该共享变量。<br>  check: 把其中一处代码注释掉再执行，不报错，所以这条排除。后来发现，是一个线程两处调用，另一个线程一处diao&#x27;yong<br>5. 共享变量没有用volatile关键字修饰,导致缓存同步问题。<br>  check: 没有共享变量，仅访问同一实例<br>6. 异常情况下,锁没有被正常释放.<br>  check: synchronized不需要手动释放<br>7. subscribe后有其它可以修改订阅的方法未加锁,如unsubscribe。<br>  check: 给所有subscribe和unsubscribe都加了锁，还是不行。后来发现poll方法也需要加锁。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反射+泛型 写一个Zookeeper工具类</title>
    <link href="/2023/09/01/20230902-%E5%8F%8D%E5%B0%84+%E6%B3%9B%E5%9E%8B%20%E5%86%99%E4%B8%80%E4%B8%AAZookeeper%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2023/09/01/20230902-%E5%8F%8D%E5%B0%84+%E6%B3%9B%E5%9E%8B%20%E5%86%99%E4%B8%80%E4%B8%AAZookeeper%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>功能简介：</p><ol><li>初始化和关闭</li><li>创建和删除节点</li><li>注册监听器</li></ol><h3 id="1-初始化和关闭"><a href="#1-初始化和关闭" class="headerlink" title="1. 初始化和关闭"></a>1. 初始化和关闭</h3><p>功能要求</p><ul><li>从配置中读取信息</li><li>设置权限</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">if</span>(zkClient == <span class="hljs-literal">null</span>)&#123;<br>            zkClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkClient</span>(zookeeperConfig.connectionString);<br>            zkClient.addAuthInfo(<span class="hljs-string">&quot;digest&quot;</span>, generateAuthInfo());<br>            zkClient.setZkSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomerSerializer</span>());<br>            logger.info(<span class="hljs-string">&quot;Connected to ZooKeeper. &quot;</span>);<br>            <span class="hljs-keyword">for</span>(Map.Entry&lt;String, String&gt; entry:zookeeperConfig.pathHandlerMap.entrySet())&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> entry.getKey();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">handlerClass</span> <span class="hljs-operator">=</span> entry.getValue();<br>                registeListener(path, handlerClass);<br>            &#125;<br>        &#125;<br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            zkClient.close();<br>            System.out.println(<span class="hljs-string">&quot;Zookeeper Client Closed.&quot;</span>);<br>        &#125;));<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        logger.error(<span class="hljs-string">&quot;Error initializing ZooKeeper client. &quot;</span>, e);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    这段代码中，选择将zkClient的初始化交给Spring管理，在容器构造完成之后执行。</p><p>​    同时，监听器的注册逻辑也在这里，注册抛出的异常在注册方法里处理了。</p><p>​    代码最后利用Java的ShutdownHook机制，在JVM退出前新建线程关闭Zookeeper。不建议大量使用这样的钩子，如果大量使用，关闭程序时会创建大量新线程，可能会出现其他错误。</p><h5 id="还有别的初始化的方式吗？"><a href="#还有别的初始化的方式吗？" class="headerlink" title="还有别的初始化的方式吗？"></a>还有别的初始化的方式吗？</h5><p>​    zkClient是单例，也可以通过单例模式+static写初始化代码。但我的参数注入是通过Spring完成的，static执行早于Spring参数注入，如果这么写会报错。</p><p>​    也可通过懒加载的方式，使用的时候再初始化。但这样就无法使用监听器了。</p><h3 id="2-创建和删除节点"><a href="#2-创建和删除节点" class="headerlink" title="2. 创建和删除节点"></a>2. 创建和删除节点</h3><p>功能要求</p><ul><li>创建和删除时先检查父节点是否存在，若不存在，抛出异常</li><li>跟zk连接时进行三次重试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(String path, String curNode, Object data)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    curNode = adjustmentNodePathUtil(curNode);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">curNodePath</span> <span class="hljs-operator">=</span> path + curNode;<br>    <span class="hljs-keyword">if</span>(!zkClient.exists(path))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Parent node &quot;</span>+ path +<span class="hljs-string">&quot; does not exist&quot;</span>);<br>    &#125;<br>    Map&lt;String, Object&gt; paramMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>    paramMap.put(<span class="hljs-string">&quot;curNodePath&quot;</span>, curNodePath);<br>    paramMap.put(<span class="hljs-string">&quot;data&quot;</span>, data);<br>    RetryUtil.RetryResult&lt;Object&gt; result = RetryUtil.executeWithRetry(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryUtil</span>.RetryCallback&lt;Object, Map&lt;String, Object&gt;&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">(Map&lt;String, Object&gt; param)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                zkClient.createPersistent(param.get(<span class="hljs-string">&quot;curNodePath&quot;</span>).toString());<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;, paramMap);<br>    <span class="hljs-keyword">return</span> result.getSuccessState();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    创建节点时先检查父节点是否存在，若不存在则报错。这里最好写一个业务报错，方便使用者对异常进行处理，根据自己需要处理报错，比如创建父节点后重试。</p><p>​    在创建节点时进行了多次重试。由于重试是个通用代码，所以我把它写到了另一个类里，并新建了RetryResult用来封装重试结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,P&gt; RetryResult&lt;T&gt; <span class="hljs-title function_">executeWithRetry</span><span class="hljs-params">(RetryCallback&lt;T,P&gt; callback, P param)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">retryCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-type">Exception</span> <span class="hljs-variable">lastException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; retryCount; i++)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> callback.call(param);<br>            <span class="hljs-keyword">return</span> RetryResult.success(result);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            lastException = e;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> RetryResult.failure(lastException);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这段代码的使用者仅需在调用时实现RetryCallback接口即可。</p><p>​    删除节点代码类似，不再重复贴出。</p><h3 id="3-注册监听器"><a href="#3-注册监听器" class="headerlink" title="3. 注册监听器"></a>3. 注册监听器</h3><p>功能要求</p><ul><li>对拓展开放，只需实现接口即可实现新的监听</li><li>无需重复注册监听器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registeListener</span><span class="hljs-params">(String path, String handlerClass)</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-type">IZkDataListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> (IZkDataListener)Class.forName(handlerClass).newInstance();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">absPath</span> <span class="hljs-operator">=</span> prefixNode + adjustmentNodePathUtil(path);<br>        zkClient.subscribeDataChanges(absPath, listener);<br>        listenerMap.put(path, listener);<br>    &#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e1)&#123;<br>        e1.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   监听注册逻辑。代码通过反射找到IZkDataListener的实现类，一一生成实例并注册。监听器监听的key由ZookeeperConfig配置，可从配置文件中读取。</p><p>  如果需要新增注册器，只需新增一个类，对IZkDataListener进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IZkDataListener</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataChange</span><span class="hljs-params">(String s, Object o)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(o.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataDeleted</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;delete: &quot;</span> + s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="为什么这里监听器只需要注册一次"><a href="#为什么这里监听器只需要注册一次" class="headerlink" title="为什么这里监听器只需要注册一次"></a>为什么这里监听器只需要注册一次</h5><p>Zookeeper的watcher是一次触发即失效，这里使用了ZkClient包，封装了监听器，当变更触发以后会自动重新注册。</p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>​    Java里的Zookeeper客户端有ZkClient和Curator，这里仅使用了ZkClient，它仅对Zookeeper客户端进行了简单的封装，如失败重连，自动重注册watcher等。从网上资料看，Curator是功能更齐全的包，留待以后研究。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%82%A8%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E6%9C%89WAL/"/>
    <url>/2023/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%82%A8%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E6%9C%89WAL/</url>
    
    <content type="html"><![CDATA[<p>磁盘结构参考： <a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">https://tech.meituan.com/2017/05/19/about-desk-io.html</a><br>对于磁盘来说，数据的顺序写和乱序写速度差别很大，顺序IO只需要一次寻址，而乱序IO需要多次寻址，因此速度较慢。数据库管理系统可以保证我们的数据按一定顺序存放，但我们无法保证存放、取用的顺序跟地址顺序是一致的，所以对于IO来说，数据库的CRUD是一种乱序IO，也就是说，它是一种很慢的操作。<br>为了能<strong>让数据库读写的速度快一些</strong>，数据库管理系统使用了内存来进行操作。我们写入的数据会先写到内存里，积攒一定数量再写入磁盘中。如果这个过程不出任何意外，那事情就一切顺利。但假如出了一些以外，比如数据库所在的电脑突然宕机重启，存在内存中的数据就会丢失。这个时候重启数据库，会丢失上一次刷盘之后写入内存的一大段数据。<br>所以，<strong>如果能让两次刷盘之间的时间间隔变小就好了</strong>。回到本文最初的分析，顺序IO速度很快，所以如果能把数据库的写入改成顺序写入就能实现这个目标。但是，数据始终有不同的顺序，无论怎么设计它的排列方式，取用的时候总是不规律取用的，所以让数据顺序读写不太可能实现。但是，我们可以<strong>在旁边追加一个顺序写的日志</strong>。数据库管理系统把磁盘分为两块，一块用来乱序存数据，一块用来顺序存日志。当我们写入数据的时候，先把数据写到内存里积攒，这时候再把我们需要的东西写到顺序存的日志内存里，日志内存积攒到一定程序会顺序写入磁盘，写完以后再写数据。因为省掉了多次寻址的时间，顺序写的日志写得会比乱序写数据快，做到尽可能减少服务宕机的损失。<br>再回归数据库的写入过程。每一次写入，我们会有下面几步：</p><ol><li>从磁盘中读取目标页到内存</li><li>修改内存中的目标页数据</li><li>将目标页的数据刷新回磁盘</li></ol><p>由于IO的主要瓶颈在寻址，读取目标页也需要寻址，因此也需要花费IO时间。可以说，假如执行5个insert语句进行一次刷盘，这5个语句刚好都在不同页，对于数据来说，我们需要执行5次读取和5次写入，总共10次寻址。<br>再次回到本文最开头的分析，顺序IO速度快是因为它需要做的寻址次数少。所以，如果WAL日志能再减少一点寻址操作就好了。比如<strong>WAL不用读取目标页</strong>。事实上，大多数数据库也是这么做的。大部份时候，WAL并不会记录目标页的数据，只会记录你执行了什么操作。数据库里会读取原来的记录，进行操作，然后覆盖原来的记录。WAL的操作日志只会记录操作，并不关心原始记录是什么样子。这样进一步减少了寻址的时间。对于上面那个例子，执行5个insert语句进行一次刷盘，对于WAL来说只需要进行一次寻址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/21/WAL%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/"/>
    <url>/2023/08/21/WAL%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h4 id="概念介绍："><a href="#概念介绍：" class="headerlink" title="概念介绍："></a>概念介绍：</h4><ul><li>**XLOG           **            Transaction Log 事务日志，是一个统称</li><li><strong>WAL段文件</strong>               磁盘中存储XLOG的区块，数据按存储页的形式组织，每一页可能有多条XLOG数据</li><li><strong>XLOG record data</strong>  写在WAL段文件中的一条一条具体的数据， 含有日志序列号LSN Log Sequence Number</li></ul><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><h5 id="段文件的结构"><a href="#段文件的结构" class="headerlink" title="段文件的结构"></a>段文件的结构</h5><p>下图就是一个具体的WAL段文件区块，整个16MB的空间是存储分配给它的空间，这个段文件的大小可以通过参数调整，但默认为16MB。在段文件内部，空间会被按页划分，每一页时一个8KB的区块。这样当PostgreSQL系统读入WAL时就可以一页一页地读入了。每一页数据都包含了首部和数据部分。除了第一页的首部稍有不同外，其他的每一页都有相同的首部。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32610216/1686159058102-b114ade8-af27-4333-93d3-d38d9a42f61b.png#averageHue=%23f5f5f5&clientId=u9288eda9-28b4-4&from=paste&height=285&id=u85073801&originHeight=570&originWidth=1327&originalType=binary&ratio=2&rotation=0&showTitle=false&size=143980&status=done&style=none&taskId=u808a58f3-244d-4af1-84a6-d09dd0c21d5&title=&width=663.5" alt="image.png"><br>图1. WAL段文件的内部布局<br>下面是两种页面的首部结构。可以看到，首页的首部除了包含校验信息外，还记录了一些WAL的元数据。对于存储来说，元数据就是用来标记位置的信息，xlp_page_addr和xlp_rem_len就起到了这个作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>    uint16         xlp_magic;    /＊ 用于正确性检查的魔数 ＊/<br>    uint16         xlp_info;     /＊ 标记位 ＊/<br>    TimeLineID    xlp_tli;       /＊ 页面中第一条记录的时间线ID ＊/<br>    XLogRecPtr    xlp_pageaddr; /＊ 当前页面的XLOG地址 ＊/<br><br>    /＊ 当当前页面放不下一条完整记录时，我们会在下一个页面继续放，xlp_rem_len存储了先前页面<br>    ＊ 记录剩余的字节数。注意，xl_rem_len包含了备份区块的数据，也就是说它会在第一个首部跟踪<br>    ＊ xl_tot_len而不是xl_len。还要注意，延续的数据不一定是对齐的 ＊/<br>    uint32         xlp_rem_len;  /＊ 记录所有剩余数据的长度 ＊/<br>    &#125; XLogPageHeaderData;<br><br><span class="hljs-keyword">typedef</span> XLogPageHeaderData ＊XLogPageHeader;<br><br>/＊ 当设置了XLP_LONG_HEADER标记位时，我们将在页首部中存储额外的字段。<br>＊ (通常是在XLOG文件中的第一个页面中) 额外的字段用于确保文件的正确性 ＊/<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogLongPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>    XLogPageHeaderData <span class="hljs-built_in">std</span>;              /＊ 标准首部 ＊/<br>    uint64               xlp_sysid;       /＊ 来自pg_control中的系统标识符 ＊/<br>    uint32               xlp_seg_size;   /＊ 交叉校验 ＊/<br>    uint32               xlp_xlog_blcksz;/＊ 交叉校验 ＊/<br>    &#125; XLogLongPageHeaderData;<br></code></pre></td></tr></table></figure><h5 id="XLOG-record-data数据结构"><a href="#XLOG-record-data数据结构" class="headerlink" title="XLOG record data数据结构"></a>XLOG record data数据结构</h5><p>接下来聊聊XLOG record data是如何组织的。<br>每一个XLOG record data也有一个它自己的首部和它的数据部分。所有XLOG record data的首部结构都是相同的，它的数据结构是XLogRecord。它的结构如下，需要注意的是它包含了xl_xid事务标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogRecord</span></span><br><span class="hljs-class">&#123;</span><br>  uint32           xl_tot_len;   /＊ 整条记录的全长 ＊/<br>  TransactionId   xl_xid;        /＊ 事务ID ＊/<br>  uint32           xl_len;        /＊ 资源管理器的数据长度 ＊/<br>  uint8             xl_info;       /＊ 标记位，如下所示 ＊/<br>  RmgrId           xl_rmid;       /＊ 本记录的资源管理器 ＊/<br>  /＊ 这里有<span class="hljs-number">2B</span>的填充，初始化为<span class="hljs-number">0</span> ＊/<br>  XLogRecPtr       xl_prev;       /＊ 在日志中指向先前记录的指针 ＊/<br>  pg_crc32         xl_crc;        /＊ 本记录的CRC ＊/<br>&#125; XLogRecord;<br></code></pre></td></tr></table></figure><p>在PostgreSQL中，9.4和9.5是一个比较大的版本分界线，通用的首部，之后的数据部分前后版本不太一致，这里仅以9.4之前版本举例。对于9.5以后的版本，感兴趣的朋友可以去翻阅文档，这里就不再一一赘述了。<br>在9.4及以前版本，XLOG record data的数据部分有两种格式，分别是备份区块的格式和非备份区块的格式。插入介绍一下，PostgreSQL的WAL除了记录数据库进行的操作外，也会隔一段时间进行一次整页写入。这些整页写入就是备份区块，记录的操作就是非备份区块。<br>备份区块的数据结构如图所示，除了首部XLogRecord以外，还包含了BkpBlock和一个具体的页面。BkpBlock相当于数据库集簇里具体页面的元数据，包含了RelFileNode（即具体的关系的指针）、ForkNumber（指向是否是关系主体还是其他）文件内的区块号和页面空闲空间的信息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32610216/1686159887760-e2fbc00f-c86f-43cc-b6fb-a20fee138316.png#averageHue=%23eeeeee&clientId=u9288eda9-28b4-4&from=paste&height=380&id=u1b7c0899&originHeight=760&originWidth=1329&originalType=binary&ratio=2&rotation=0&showTitle=false&size=244854&status=done&style=none&taskId=u41338af3-4b56-4853-b924-b46bfd57d56&title=&width=664.5" alt="image.png"><br>        而在非备份区块中，数据结构会因操作而异，一条INSERT语句的XLOG记录由XlLogRecord结构体、xl_heap_insert结构和被插入的元组组成。xl_heap_insert用于定位插入位置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
