<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%82%A8%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E6%9C%89WAL/"/>
    <url>/2023/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%82%A8%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E6%9C%89WAL/</url>
    
    <content type="html"><![CDATA[<p>磁盘结构参考： <a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">https://tech.meituan.com/2017/05/19/about-desk-io.html</a><br>对于磁盘来说，数据的顺序写和乱序写速度差别很大，顺序IO只需要一次寻址，而乱序IO需要多次寻址，因此速度较慢。数据库管理系统可以保证我们的数据按一定顺序存放，但我们无法保证存放、取用的顺序跟地址顺序是一致的，所以对于IO来说，数据库的CRUD是一种乱序IO，也就是说，它是一种很慢的操作。<br>为了能<strong>让数据库读写的速度快一些</strong>，数据库管理系统使用了内存来进行操作。我们写入的数据会先写到内存里，积攒一定数量再写入磁盘中。如果这个过程不出任何意外，那事情就一切顺利。但假如出了一些以外，比如数据库所在的电脑突然宕机重启，存在内存中的数据就会丢失。这个时候重启数据库，会丢失上一次刷盘之后写入内存的一大段数据。<br>所以，<strong>如果能让两次刷盘之间的时间间隔变小就好了</strong>。回到本文最初的分析，顺序IO速度很快，所以如果能把数据库的写入改成顺序写入就能实现这个目标。但是，数据始终有不同的顺序，无论怎么设计它的排列方式，取用的时候总是不规律取用的，所以让数据顺序读写不太可能实现。但是，我们可以<strong>在旁边追加一个顺序写的日志</strong>。数据库管理系统把磁盘分为两块，一块用来乱序存数据，一块用来顺序存日志。当我们写入数据的时候，先把数据写到内存里积攒，这时候再把我们需要的东西写到顺序存的日志内存里，日志内存积攒到一定程序会顺序写入磁盘，写完以后再写数据。因为省掉了多次寻址的时间，顺序写的日志写得会比乱序写数据快，做到尽可能减少服务宕机的损失。<br>再回归数据库的写入过程。每一次写入，我们会有下面几步：</p><ol><li>从磁盘中读取目标页到内存</li><li>修改内存中的目标页数据</li><li>将目标页的数据刷新回磁盘</li></ol><p>由于IO的主要瓶颈在寻址，读取目标页也需要寻址，因此也需要花费IO时间。可以说，假如执行5个insert语句进行一次刷盘，这5个语句刚好都在不同页，对于数据来说，我们需要执行5次读取和5次写入，总共10次寻址。<br>再次回到本文最开头的分析，顺序IO速度快是因为它需要做的寻址次数少。所以，如果WAL日志能再减少一点寻址操作就好了。比如<strong>WAL不用读取目标页</strong>。事实上，大多数数据库也是这么做的。大部份时候，WAL并不会记录目标页的数据，只会记录你执行了什么操作。数据库里会读取原来的记录，进行操作，然后覆盖原来的记录。WAL的操作日志只会记录操作，并不关心原始记录是什么样子。这样进一步减少了寻址的时间。对于上面那个例子，执行5个insert语句进行一次刷盘，对于WAL来说只需要进行一次寻址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/21/WAL%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/"/>
    <url>/2023/08/21/WAL%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h4 id="概念介绍："><a href="#概念介绍：" class="headerlink" title="概念介绍："></a>概念介绍：</h4><ul><li>**XLOG           **            Transaction Log 事务日志，是一个统称</li><li><strong>WAL段文件</strong>               磁盘中存储XLOG的区块，数据按存储页的形式组织，每一页可能有多条XLOG数据</li><li><strong>XLOG record data</strong>  写在WAL段文件中的一条一条具体的数据， 含有日志序列号LSN Log Sequence Number</li></ul><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><h5 id="段文件的结构"><a href="#段文件的结构" class="headerlink" title="段文件的结构"></a>段文件的结构</h5><p>下图就是一个具体的WAL段文件区块，整个16MB的空间是存储分配给它的空间，这个段文件的大小可以通过参数调整，但默认为16MB。在段文件内部，空间会被按页划分，每一页时一个8KB的区块。这样当PostgreSQL系统读入WAL时就可以一页一页地读入了。每一页数据都包含了首部和数据部分。除了第一页的首部稍有不同外，其他的每一页都有相同的首部。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32610216/1686159058102-b114ade8-af27-4333-93d3-d38d9a42f61b.png#averageHue=%23f5f5f5&clientId=u9288eda9-28b4-4&from=paste&height=285&id=u85073801&originHeight=570&originWidth=1327&originalType=binary&ratio=2&rotation=0&showTitle=false&size=143980&status=done&style=none&taskId=u808a58f3-244d-4af1-84a6-d09dd0c21d5&title=&width=663.5" alt="image.png"><br>图1. WAL段文件的内部布局<br>下面是两种页面的首部结构。可以看到，首页的首部除了包含校验信息外，还记录了一些WAL的元数据。对于存储来说，元数据就是用来标记位置的信息，xlp_page_addr和xlp_rem_len就起到了这个作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>    uint16         xlp_magic;    /＊ 用于正确性检查的魔数 ＊/<br>    uint16         xlp_info;     /＊ 标记位 ＊/<br>    TimeLineID    xlp_tli;       /＊ 页面中第一条记录的时间线ID ＊/<br>    XLogRecPtr    xlp_pageaddr; /＊ 当前页面的XLOG地址 ＊/<br><br>    /＊ 当当前页面放不下一条完整记录时，我们会在下一个页面继续放，xlp_rem_len存储了先前页面<br>    ＊ 记录剩余的字节数。注意，xl_rem_len包含了备份区块的数据，也就是说它会在第一个首部跟踪<br>    ＊ xl_tot_len而不是xl_len。还要注意，延续的数据不一定是对齐的 ＊/<br>    uint32         xlp_rem_len;  /＊ 记录所有剩余数据的长度 ＊/<br>    &#125; XLogPageHeaderData;<br><br><span class="hljs-keyword">typedef</span> XLogPageHeaderData ＊XLogPageHeader;<br><br>/＊ 当设置了XLP_LONG_HEADER标记位时，我们将在页首部中存储额外的字段。<br>＊ (通常是在XLOG文件中的第一个页面中) 额外的字段用于确保文件的正确性 ＊/<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogLongPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>    XLogPageHeaderData <span class="hljs-built_in">std</span>;              /＊ 标准首部 ＊/<br>    uint64               xlp_sysid;       /＊ 来自pg_control中的系统标识符 ＊/<br>    uint32               xlp_seg_size;   /＊ 交叉校验 ＊/<br>    uint32               xlp_xlog_blcksz;/＊ 交叉校验 ＊/<br>    &#125; XLogLongPageHeaderData;<br></code></pre></td></tr></table></figure><h5 id="XLOG-record-data数据结构"><a href="#XLOG-record-data数据结构" class="headerlink" title="XLOG record data数据结构"></a>XLOG record data数据结构</h5><p>接下来聊聊XLOG record data是如何组织的。<br>每一个XLOG record data也有一个它自己的首部和它的数据部分。所有XLOG record data的首部结构都是相同的，它的数据结构是XLogRecord。它的结构如下，需要注意的是它包含了xl_xid事务标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogRecord</span></span><br><span class="hljs-class">&#123;</span><br>  uint32           xl_tot_len;   /＊ 整条记录的全长 ＊/<br>  TransactionId   xl_xid;        /＊ 事务ID ＊/<br>  uint32           xl_len;        /＊ 资源管理器的数据长度 ＊/<br>  uint8             xl_info;       /＊ 标记位，如下所示 ＊/<br>  RmgrId           xl_rmid;       /＊ 本记录的资源管理器 ＊/<br>  /＊ 这里有<span class="hljs-number">2B</span>的填充，初始化为<span class="hljs-number">0</span> ＊/<br>  XLogRecPtr       xl_prev;       /＊ 在日志中指向先前记录的指针 ＊/<br>  pg_crc32         xl_crc;        /＊ 本记录的CRC ＊/<br>&#125; XLogRecord;<br></code></pre></td></tr></table></figure><p>在PostgreSQL中，9.4和9.5是一个比较大的版本分界线，通用的首部，之后的数据部分前后版本不太一致，这里仅以9.4之前版本举例。对于9.5以后的版本，感兴趣的朋友可以去翻阅文档，这里就不再一一赘述了。<br>在9.4及以前版本，XLOG record data的数据部分有两种格式，分别是备份区块的格式和非备份区块的格式。插入介绍一下，PostgreSQL的WAL除了记录数据库进行的操作外，也会隔一段时间进行一次整页写入。这些整页写入就是备份区块，记录的操作就是非备份区块。<br>备份区块的数据结构如图所示，除了首部XLogRecord以外，还包含了BkpBlock和一个具体的页面。BkpBlock相当于数据库集簇里具体页面的元数据，包含了RelFileNode（即具体的关系的指针）、ForkNumber（指向是否是关系主体还是其他）文件内的区块号和页面空闲空间的信息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32610216/1686159887760-e2fbc00f-c86f-43cc-b6fb-a20fee138316.png#averageHue=%23eeeeee&clientId=u9288eda9-28b4-4&from=paste&height=380&id=u1b7c0899&originHeight=760&originWidth=1329&originalType=binary&ratio=2&rotation=0&showTitle=false&size=244854&status=done&style=none&taskId=u41338af3-4b56-4853-b924-b46bfd57d56&title=&width=664.5" alt="image.png"><br>        而在非备份区块中，数据结构会因操作而异，一条INSERT语句的XLOG记录由XlLogRecord结构体、xl_heap_insert结构和被插入的元组组成。xl_heap_insert用于定位插入位置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
