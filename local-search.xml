<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java中的软引用和它的测试</title>
    <link href="/2023/09/07/20230907-Java%E4%B8%AD%E7%9A%84%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%AE%83%E7%9A%84%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/09/07/20230907-Java%E4%B8%AD%E7%9A%84%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%AE%83%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Java中的软引用和它的测试"><a href="#Java中的软引用和它的测试" class="headerlink" title="Java中的软引用和它的测试"></a>Java中的软引用和它的测试</h3><h4 id="软引用介绍"><a href="#软引用介绍" class="headerlink" title="软引用介绍"></a>软引用介绍</h4><h3 id="软引用和它的测试"><a href="#软引用和它的测试" class="headerlink" title="软引用和它的测试"></a>软引用和它的测试</h3><p>​将被回收的困难程度排序，应该是强引用&gt;软引用&gt;弱引用。对比软引用和对引用，软引用的回收时间是不可预测的，它仅在内存紧张的GC进行回收。而弱引用会在下一次GC时被回收。</p><h4 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h4><p>​为了验证它的回收，我们可以创建一个持有SoftReference的list，不断往里塞大对象，不断触发GC，查看结果。注，内存紧张回收后，该对象被回收，但指向该对象的指针没有被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;<span class="hljs-type">byte</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;first data in list: &quot;</span> + list.get(<span class="hljs-number">0</span>).get());<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSoftReference</span><span class="hljs-params">()</span>&#123;<br>    ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;<span class="hljs-type">byte</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>]));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>        () -&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;soft reference list size: &quot;</span> + list.size());<br>                System.out.println(<span class="hljs-string">&quot;first data in list: &quot;</span> + list.get(<span class="hljs-number">0</span>).get());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">300L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    ).start();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.currentThread().join();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        System.exit(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM参数如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">-<span class="hljs-keyword">ea</span> -<span class="hljs-keyword">verbose</span>:gc -Xms4m -Xmx4m -Xmn2m <br></code></pre></td></tr></table></figure><h4 id="分析测试结果"><a href="#分析测试结果" class="headerlink" title="分析测试结果"></a>分析测试结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;first data in list: &quot;</span> + list.get(<span class="hljs-number">0</span>).get());<br></code></pre></td></tr></table></figure><p>​上面语句不会报空指针异常，这说明GC回收了软引用对象后，并没有回收软引用变量本身，如果希望软引用变量被回收，最好将它添加到reference queue再手动回收。</p><p>打印日志如下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3039</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2586</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0083289</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3039</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2610</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0100043</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">soft</span> <span class="hljs-variable">reference</span> <span class="hljs-variable">list</span> <span class="hljs-variable">size</span><span class="hljs-operator">:</span> <span class="hljs-number">1</span><br><span class="hljs-variable">first</span> <span class="hljs-variable">data</span> <span class="hljs-variable">in</span> <span class="hljs-variable">list</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">B</span><span class="hljs-operator">@</span><span class="hljs-number">2781</span><span class="hljs-variable">fef4</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3035</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2732</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0090069</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3039</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2896</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0137084</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3029</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3007</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0065464</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3021</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2986</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0062080</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3029</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3010</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0056912</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3028</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3010</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0059427</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span>  <span class="hljs-number">3010</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">2704</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">3584</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0124300</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">soft</span> <span class="hljs-variable">reference</span> <span class="hljs-variable">list</span> <span class="hljs-variable">size</span><span class="hljs-operator">:</span> <span class="hljs-number">1</span><br><span class="hljs-variable">first</span> <span class="hljs-variable">data</span> <span class="hljs-variable">in</span> <span class="hljs-variable">list</span><span class="hljs-operator">:</span> <span class="hljs-variable">null</span><br></code></pre></td></tr></table></figure><p>​通过这段代码我们可以观察到，在GC的初始几次循环中尽管发生了垃圾回收，但是软引用对象还没有被回收。这是因为JVM认为内存空间还充足,可以继续保留软引用对象。但是随着程序运行，内存空间逐渐紧张，在某一次GC过程中，JVM终于决定回收软引用对象以释放更多内存。此时我们打印软引用所引用的对象,其值为null。这表示软引用对象已经被回收了。</p><p>​但需要注意的是，原本指向这个软引用对象的软引用变量list本身还存在，它仍然保持对这个已经被回收对象的引用，只是这个引用现在无效了，如下图。如果程序不及时清理这种无效引用,可能会渐渐占用较多内存。</p><p><img src="/%5Cimg%5C230907-%E8%BD%AF%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%9B%9E%E6%94%B6.png" alt="230907-软引用变量回收"></p><h4 id="软引用变量的回收"><a href="#软引用变量的回收" class="headerlink" title="软引用变量的回收"></a>软引用变量的回收</h4><p>​为了避免上述情况，我们可以主动回收软引用变量。</p><h5 id="放入引用队列进行回收"><a href="#放入引用队列进行回收" class="headerlink" title="放入引用队列进行回收"></a>放入引用队列进行回收</h5><p>将软引用变量放入引用队列里，在回收的时候手动释放它。将创建对象并塞入对象的代码改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br> <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <br>     list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;<span class="hljs-type">byte</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>], referenceQueue));<br> &#125;<br></code></pre></td></tr></table></figure><p>​    使用另一个线程不断扫描referenceQueue，当软引用对象被回收时，软引用变量就会被放入referenceQueue中，我们可以通过手动把它设置为null，或者从list中移除它来回收。</p><h5 id="WeakHashMap进行回收"><a href="#WeakHashMap进行回收" class="headerlink" title="WeakHashMap进行回收"></a>WeakHashMap进行回收</h5><p>​另外，也可以使用WeakHashMap来储存，储存的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakHashMap&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;, <span class="hljs-type">byte</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>]);<br>    map.put(obj, obj.get());<br>    System.out.println(<span class="hljs-string">&quot;add data in map.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>命令行输出</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">[Full GC (Ergonomics)  3014K-&gt;2907K(3584K), 0.0063295 secs]<br>soft reference map size: 2<br>first data in map: java.lang.ref.SoftReference@4c67258e=[B@58a828a3<br>[Full GC (Ergonomics)  2912K-&gt;2807K(3584K), 0.0058464 secs]<br>add data in map.<br>[Full GC (Ergonomics)  2913K-&gt;2807K(3584K), 0.0080876 secs]<br>add data in map.<br>[Full GC (Ergonomics)  2912K-&gt;2807K(3584K), 0.0067576 secs]<br>add data in map.<br>soft reference map size: 1<br>first data in map: java.lang.ref.SoftReference@2b0d69c0=[B@1daaadd2<br></code></pre></td></tr></table></figure><p>​分析日志，可以看到，最开始map中已经有两个对象，后面也在不断往map中插入数据。但经过几轮回收后，map size变为了1。这说明，JVM中间经过了一次内存紧张的回收，将我们建立的软引用变量回收了，而在下一次回收中，weakHashMap识别到它的value被回收，于是主动删除了这个键值对。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>写一个用zk监听变化的Kafka Consumer</title>
    <link href="/2023/09/02/%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%A8zk%E7%9B%91%E5%90%AC%E5%8F%98%E5%8C%96%E7%9A%84kafkaconsumer/"/>
    <url>/2023/09/02/%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%A8zk%E7%9B%91%E5%90%AC%E5%8F%98%E5%8C%96%E7%9A%84kafkaconsumer/</url>
    
    <content type="html"><![CDATA[<p>功能简介：</p><ol><li>写一个kafka consumer manager类</li><li>实现一个具体的kafka consumer</li><li>注册zk监听器，监听zk变化修改consumer订阅的topic</li></ol><h3 id="1-写一个kafka-consumer-manager类"><a href="#1-写一个kafka-consumer-manager类" class="headerlink" title="1. 写一个kafka consumer manager类"></a>1. 写一个kafka consumer manager类</h3><ul><li>kafka consumer manager类，用于管理kafka consumer</li><li>找到每个消费者，订阅各自主题</li><li>将任务交给线程池处理</li><li>设置关闭函数</li></ul><h4 id="1-1-kafka-consumer-manager类，用于管理kafka-consumer"><a href="#1-1-kafka-consumer-manager类，用于管理kafka-consumer" class="headerlink" title="1.1 kafka consumer manager类，用于管理kafka consumer"></a>1.1 kafka consumer manager类，用于管理kafka consumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ConcurrentMap&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; kafkaConsumers;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(kafkaConsumers == <span class="hljs-literal">null</span>)&#123;<br>        kafkaConsumers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Reflections</span> <span class="hljs-variable">reflections</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reflections</span>(<span class="hljs-string">&quot;src.main.com.channon.util&quot;</span>);<br>        Set&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KafkaConsumer</span>&gt;&gt; subTypes = reflections.getSubTypesOf(KafkaConsumer.class);<br>        subTypes.forEach(clazz -&gt; &#123;<br>        <span class="hljs-type">KafkaConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> clazz.getConstructor(Properties.class).newInstance(kafkaConfig.consumerConfigs());<br>            <span class="hljs-comment">// 消费者订阅主题</span><br>            <span class="hljs-comment">// 消费者拉取消息代码交给线程池</span><br>            <span class="hljs-comment">// 设置关闭处理</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建了一个KafkaConsumerManager类，通过反射获取所有继承了KafkaConsumer的子类，再作处理。</p><h4 id="1-2-消费者订阅各自主题"><a href="#1-2-消费者订阅各自主题" class="headerlink" title="1.2 消费者订阅各自主题"></a>1.2 消费者订阅各自主题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribeTopic</span><span class="hljs-params">(Class clazz, KafkaConsumer consumer)</span>&#123;<br>    Set&lt;Map.Entry&lt;String, String&gt;&gt; listener = zookeeperConfig.pathHandlerMap.entrySet();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">configTopic</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;String, String&gt; entry:listener)&#123;<br>        <span class="hljs-keyword">if</span>(listener.equals(clazz.getName()))&#123;<br>            configTopic = <span class="hljs-literal">true</span>;<br>            consumer.subscribe(Collections.singleton(entry.getKey()));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!configTopic)&#123;<br>        consumer.subscribe(Collections.singleton(kafkaConfig.topic));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    从配置中读取每个消费者对应的主题，如果有单独配置就读取单独配置，如果没有就读取通用配置。这里配置获取方式各有不同，大家可以选择各自的实现方式。唯一需要注意的是， 配置获取的时间应该先于manager init代码运行的时间。</p><h4 id="1-3-将任务交给线程池处理"><a href="#1-3-将任务交给线程池处理" class="headerlink" title="1.3 将任务交给线程池处理"></a>1.3 将任务交给线程池处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">kafkaConsumerPool.addTask(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (subscribeLock) &#123;<br>                    <span class="hljs-type">ConsumerRecords</span> <span class="hljs-variable">records</span> <span class="hljs-operator">=</span> consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (WakeupException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            consumer.close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>​    设置时间，每个消费者隔一段时间会从kafka里拉取消息，consumer交由线程池管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaConsumerPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService executorService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    KafkaConsumerManager kafkaConsumerManager;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(Runnable task)</span>&#123;<br>        executorService.submit(task);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>        Map&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; consumers = kafkaConsumerManager.kafkaConsumers();<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; entry : consumers.entrySet())&#123;<br>            entry.getValue().wakeup();<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面一段是线程池的代码。需要注意的是，kafka consumer是需要一直在后台运行的，所以最好是设置一个固定线程数的线程池，线程数 &#x3D; 消费者数。</p><p>​    线程池关闭的时候会获取所有的消费者，并调用wakeup()。</p><h5 id="为什么关闭消费者时调用的是wakeup-而不是close-？"><a href="#为什么关闭消费者时调用的是wakeup-而不是close-？" class="headerlink" title="为什么关闭消费者时调用的是wakeup()而不是close()？"></a>为什么关闭消费者时调用的是wakeup()而不是close()？</h5><p>​    wakeup是更轻量也更安全的方法。</p><p>​    轻量：它会将client里的wakeup设置为true，kafka在下一次poll数据时就会读取到wakeup设置，并抛出一个WakeUpException。调用线程更改完变量即可退出，无需等待kafka consumer彻底关闭。</p><p>​    安全： wakeup会在下次poll之前抛出异常，而close可能打断poll的过程，使得缓存区的该批数据丢失，这批数据可能处于未处理、处理中、已处理未提交位移的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// KafkaConsumer源码</span><br><span class="hljs-keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Timer timer, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> includeMetadataInTimeout)</span> &#123;<br>        acquireAndEnsureOpen();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ......<br>            &#125;<br><br>            <span class="hljs-keyword">do</span> &#123;<br>                client.maybeTriggerWakeup(); <span class="hljs-comment">// wakeup会在这里抛出异常</span><br><br>                <span class="hljs-keyword">final</span> Fetch&lt;K, V&gt; fetch = pollForFetches(timer);<br>                <span class="hljs-keyword">if</span> (!fetch.isEmpty()) &#123;<br>                    ......<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.interceptors.onConsume(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsumerRecords</span>&lt;&gt;(fetch.records()));<br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (timer.notExpired());<br><br>            <span class="hljs-keyword">return</span> ConsumerRecords.empty();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            release();<br>            <span class="hljs-built_in">this</span>.kafkaConsumerMetrics.recordPollEnd(timer.currentTimeMs());<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-4-设置关闭函数"><a href="#1-4-设置关闭函数" class="headerlink" title="1.4 设置关闭函数"></a>1.4 设置关闭函数</h4><p>在zookeeper util中，我们将关闭函数写在Runtime预留的callback函数里，但这里使用了线程池，所以在线程池中处理关闭即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>    Map&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; consumers = kafkaConsumerManager.kafkaConsumers();<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;String, KafkaConsumer&lt;String, KafkaConsumer&gt;&gt; entry : consumers.entrySet())&#123;<br>        entry.getValue().wakeup();<br>    &#125;<br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-实现一个具体的Kafka-Consumer"><a href="#2-实现一个具体的Kafka-Consumer" class="headerlink" title="2. 实现一个具体的Kafka Consumer"></a>2. 实现一个具体的Kafka Consumer</h3><p>​    子类继承KafkaConsumer即可。对于我们需要的操作，可以通过重写poll函数来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumerRecords&lt;String, Object&gt; <span class="hljs-title function_">poll</span><span class="hljs-params">(Duration timeout)</span> &#123;<br><br>    <span class="hljs-comment">// call KafkaConsumer.poll() to get messages</span><br>    ConsumerRecords&lt;String, Object&gt; records = <span class="hljs-built_in">super</span>.poll(timeout);<br><br>    <span class="hljs-comment">// iterate records, print each message</span><br>    <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, Object&gt; record : records) &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Consumed by %s, topic = %s, partition = %d, offset = %d, key = %s, value = %s \n&quot;</span>,<br>                <span class="hljs-built_in">this</span>.getClass().getName(), record.topic(), record.partition(), record.offset(), record.key(), record.value());<br>    &#125;<br><br>    <span class="hljs-comment">// return records to user</span><br>    <span class="hljs-keyword">return</span> records;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上文先调用父类的poll函数拉取消息，然后执行我们期望的操作——打印信息，最后返回。</p><p>​    之前提到的close可能随时打断这里的任何操作，如执行完了super.poll，但还没有处理，就关闭了。这就会造成数据丢失。</p><h3 id="3-注册zk监听器，监听zk变化修改consumer订阅的topic"><a href="#3-注册zk监听器，监听zk变化修改consumer订阅的topic" class="headerlink" title="3. 注册zk监听器，监听zk变化修改consumer订阅的topic"></a>3. 注册zk监听器，监听zk变化修改consumer订阅的topic</h3><ul><li>不建议的操作</li><li>zk监听器实现</li><li>并发问题</li></ul><h4 id="3-1-不建议的操作"><a href="#3-1-不建议的操作" class="headerlink" title="3.1 不建议的操作"></a>3.1 不建议的操作</h4><p>我在几次尝试中发现，实时修改kafka consumer订阅的topic是一个非常不好的操作。</p><ol><li><p>kafka重平衡消费者导致信息丢失。consumer修改topic对于kafka是个消费者下线再上线的过程，这就回到了经典的kafka重平衡导致数据丢失问题。</p></li><li><p>kakfa consumer不是并发安全的实现。实时修改kafka consumer会遇到非常难处理的并发冲突，如果需要绝对安全又需要加锁，这会拖慢consumer的执行。</p><p>另外，kafka consumer检查到并发冲突后会抛出异常ConcurrentModificationException，需要妥善处理。</p></li></ol><p>​    我在查找网上方案的时候发现大家有两种实现方法，一种是检测到topic变更，直接close消费者再新建，另一种就是加锁。我选择了加锁实现。</p><h4 id="3-2-zk监听器实现"><a href="#3-2-zk监听器实现" class="headerlink" title="3.2 zk监听器实现"></a>3.2 zk监听器实现</h4><p>​    我们把kafka的topic配置到zookeeper上，写了一个zk listener，当zk node数据变更时就调用kafka consumer变更topic。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaPrintTopicListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IZkDataListener</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span>&#123;<br>        KafkaConsumerManager manager= ApplicationContextUtil.getBean(KafkaConsumerManager.class);<br>        <span class="hljs-type">KafkaConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> manager.kafkaConsumers().get(PrintConsumer.class.getName());<br>        <span class="hljs-keyword">synchronized</span> (subscribeLock)&#123;<br>            consumer.unsubscribe();<br>            consumer.subscribe(Collections.singleton(data.toString()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​     需要注意的是，这个类作为pojo类，需要使用到bean类KafkaConsumerManager，这涉及bean注入的问题。我在这里选择的实现是，创建一个ApplicationContextUtil，使得程序可以在任意地方通过这个Util获取Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextUtil</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext context;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ApplicationContextUtil</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>        ApplicationContextUtil.context = context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApplicationContext <span class="hljs-title function_">getApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getBean(beanClass);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-并发问题"><a href="#3-3-并发问题" class="headerlink" title="3.3 并发问题"></a>3.3 并发问题</h4><p>​    KafkaConsumerManager、KafkaPrintTopicListener和线程池都会对consumer进行更改，而consumer本身是线程不安全的，这里的访问会报错。我的解决方案是，在consumer类中创建一个Object类作为锁对象，对三个地方都加锁。</p><p>​    但是这不是一个优良的实现。如果在修改topic时，线程池的poll操作被阻塞，它就没法完成“定时拉取”的任务了。</p><p>​    另外，解决这个并发冲突的过程也是很有意思的过程。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">如果给两个调用共享变量的地方分别加锁,还是存在并发冲突的可能,原因可能有:<br>1. 两个地方加的锁对象不一样,需要使用同一对象锁才能起到互斥的效果。  <br>  check: 打印输出或日志检查,在加锁的地方打印出锁对象的引用,确认是否是同一个对象。引用地址相同，所以是同一个对象。<br>2. 加锁的范围不够,需要扩大锁的范围,直到包含所有访问共享变量的语句。<br>  check: 扩大到不能再大了……还是不行<br>3. 存在死锁情况,一个线程获取锁A等待锁B,另一个线程获取锁B等待锁A,导致互相等待。<br>  check: 应该不是<br>4. 有其它线程没有加锁也访问了该共享变量。<br>  check: 把其中一处代码注释掉再执行，不报错，所以这条排除。后来发现，是一个线程两处调用，另一个线程一处diao&#x27;yong<br>5. 共享变量没有用volatile关键字修饰,导致缓存同步问题。<br>  check: 没有共享变量，仅访问同一实例<br>6. 异常情况下,锁没有被正常释放.<br>  check: synchronized不需要手动释放<br>7. subscribe后有其它可以修改订阅的方法未加锁,如unsubscribe。<br>  check: 给所有subscribe和unsubscribe都加了锁，还是不行。后来发现poll方法也需要加锁。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反射+泛型 写一个Zookeeper工具类</title>
    <link href="/2023/09/01/%E5%8F%8D%E5%B0%84+%E6%B3%9B%E5%9E%8B%20%E5%86%99%E4%B8%80%E4%B8%AAZookeeper%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2023/09/01/%E5%8F%8D%E5%B0%84+%E6%B3%9B%E5%9E%8B%20%E5%86%99%E4%B8%80%E4%B8%AAZookeeper%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>功能简介：</p><ol><li>初始化和关闭</li><li>创建和删除节点</li><li>注册监听器</li></ol><h3 id="1-初始化和关闭"><a href="#1-初始化和关闭" class="headerlink" title="1. 初始化和关闭"></a>1. 初始化和关闭</h3><p>功能要求</p><ul><li>从配置中读取信息</li><li>设置权限</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">if</span>(zkClient == <span class="hljs-literal">null</span>)&#123;<br>            zkClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkClient</span>(zookeeperConfig.connectionString);<br>            zkClient.addAuthInfo(<span class="hljs-string">&quot;digest&quot;</span>, generateAuthInfo());<br>            zkClient.setZkSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomerSerializer</span>());<br>            logger.info(<span class="hljs-string">&quot;Connected to ZooKeeper. &quot;</span>);<br>            <span class="hljs-keyword">for</span>(Map.Entry&lt;String, String&gt; entry:zookeeperConfig.pathHandlerMap.entrySet())&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> entry.getKey();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">handlerClass</span> <span class="hljs-operator">=</span> entry.getValue();<br>                registeListener(path, handlerClass);<br>            &#125;<br>        &#125;<br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            zkClient.close();<br>            System.out.println(<span class="hljs-string">&quot;Zookeeper Client Closed.&quot;</span>);<br>        &#125;));<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        logger.error(<span class="hljs-string">&quot;Error initializing ZooKeeper client. &quot;</span>, e);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    这段代码中，选择将zkClient的初始化交给Spring管理，在容器构造完成之后执行。</p><p>​    同时，监听器的注册逻辑也在这里，注册抛出的异常在注册方法里处理了。</p><p>​    代码最后利用Java的ShutdownHook机制，在JVM退出前新建线程关闭Zookeeper。不建议大量使用这样的钩子，如果大量使用，关闭程序时会创建大量新线程，可能会出现其他错误。</p><h5 id="还有别的初始化的方式吗？"><a href="#还有别的初始化的方式吗？" class="headerlink" title="还有别的初始化的方式吗？"></a>还有别的初始化的方式吗？</h5><p>​    zkClient是单例，也可以通过单例模式+static写初始化代码。但我的参数注入是通过Spring完成的，static执行早于Spring参数注入，如果这么写会报错。</p><p>​    也可通过懒加载的方式，使用的时候再初始化。但这样就无法使用监听器了。</p><h3 id="2-创建和删除节点"><a href="#2-创建和删除节点" class="headerlink" title="2. 创建和删除节点"></a>2. 创建和删除节点</h3><p>功能要求</p><ul><li>创建和删除时先检查父节点是否存在，若不存在，抛出异常</li><li>跟zk连接时进行三次重试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(String path, String curNode, Object data)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    curNode = adjustmentNodePathUtil(curNode);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">curNodePath</span> <span class="hljs-operator">=</span> path + curNode;<br>    <span class="hljs-keyword">if</span>(!zkClient.exists(path))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Parent node &quot;</span>+ path +<span class="hljs-string">&quot; does not exist&quot;</span>);<br>    &#125;<br>    Map&lt;String, Object&gt; paramMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>    paramMap.put(<span class="hljs-string">&quot;curNodePath&quot;</span>, curNodePath);<br>    paramMap.put(<span class="hljs-string">&quot;data&quot;</span>, data);<br>    RetryUtil.RetryResult&lt;Object&gt; result = RetryUtil.executeWithRetry(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryUtil</span>.RetryCallback&lt;Object, Map&lt;String, Object&gt;&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">(Map&lt;String, Object&gt; param)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                zkClient.createPersistent(param.get(<span class="hljs-string">&quot;curNodePath&quot;</span>).toString());<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;, paramMap);<br>    <span class="hljs-keyword">return</span> result.getSuccessState();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    创建节点时先检查父节点是否存在，若不存在则报错。这里最好写一个业务报错，方便使用者对异常进行处理，根据自己需要处理报错，比如创建父节点后重试。</p><p>​    在创建节点时进行了多次重试。由于重试是个通用代码，所以我把它写到了另一个类里，并新建了RetryResult用来封装重试结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,P&gt; RetryResult&lt;T&gt; <span class="hljs-title function_">executeWithRetry</span><span class="hljs-params">(RetryCallback&lt;T,P&gt; callback, P param)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">retryCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-type">Exception</span> <span class="hljs-variable">lastException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; retryCount; i++)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> callback.call(param);<br>            <span class="hljs-keyword">return</span> RetryResult.success(result);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            lastException = e;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> RetryResult.failure(lastException);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这段代码的使用者仅需在调用时实现RetryCallback接口即可。</p><p>​    删除节点代码类似，不再重复贴出。</p><h3 id="3-注册监听器"><a href="#3-注册监听器" class="headerlink" title="3. 注册监听器"></a>3. 注册监听器</h3><p>功能要求</p><ul><li>对拓展开放，只需实现接口即可实现新的监听</li><li>无需重复注册监听器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registeListener</span><span class="hljs-params">(String path, String handlerClass)</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-type">IZkDataListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> (IZkDataListener)Class.forName(handlerClass).newInstance();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">absPath</span> <span class="hljs-operator">=</span> prefixNode + adjustmentNodePathUtil(path);<br>        zkClient.subscribeDataChanges(absPath, listener);<br>        listenerMap.put(path, listener);<br>    &#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e1)&#123;<br>        e1.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   监听注册逻辑。代码通过反射找到IZkDataListener的实现类，一一生成实例并注册。监听器监听的key由ZookeeperConfig配置，可从配置文件中读取。</p><p>  如果需要新增注册器，只需新增一个类，对IZkDataListener进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IZkDataListener</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataChange</span><span class="hljs-params">(String s, Object o)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(o.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDataDeleted</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;delete: &quot;</span> + s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="为什么这里监听器只需要注册一次"><a href="#为什么这里监听器只需要注册一次" class="headerlink" title="为什么这里监听器只需要注册一次"></a>为什么这里监听器只需要注册一次</h5><p>Zookeeper的watcher是一次触发即失效，这里使用了ZkClient包，封装了监听器，当变更触发以后会自动重新注册。</p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>​    Java里的Zookeeper客户端有ZkClient和Curator，这里仅使用了ZkClient，它仅对Zookeeper客户端进行了简单的封装，如失败重连，自动重注册watcher等。从网上资料看，Curator是功能更齐全的包，留待以后研究。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%82%A8%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E6%9C%89WAL/"/>
    <url>/2023/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%82%A8%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E6%9C%89WAL/</url>
    
    <content type="html"><![CDATA[<p>磁盘结构参考： <a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">https://tech.meituan.com/2017/05/19/about-desk-io.html</a><br>对于磁盘来说，数据的顺序写和乱序写速度差别很大，顺序IO只需要一次寻址，而乱序IO需要多次寻址，因此速度较慢。数据库管理系统可以保证我们的数据按一定顺序存放，但我们无法保证存放、取用的顺序跟地址顺序是一致的，所以对于IO来说，数据库的CRUD是一种乱序IO，也就是说，它是一种很慢的操作。<br>为了能<strong>让数据库读写的速度快一些</strong>，数据库管理系统使用了内存来进行操作。我们写入的数据会先写到内存里，积攒一定数量再写入磁盘中。如果这个过程不出任何意外，那事情就一切顺利。但假如出了一些以外，比如数据库所在的电脑突然宕机重启，存在内存中的数据就会丢失。这个时候重启数据库，会丢失上一次刷盘之后写入内存的一大段数据。<br>所以，<strong>如果能让两次刷盘之间的时间间隔变小就好了</strong>。回到本文最初的分析，顺序IO速度很快，所以如果能把数据库的写入改成顺序写入就能实现这个目标。但是，数据始终有不同的顺序，无论怎么设计它的排列方式，取用的时候总是不规律取用的，所以让数据顺序读写不太可能实现。但是，我们可以<strong>在旁边追加一个顺序写的日志</strong>。数据库管理系统把磁盘分为两块，一块用来乱序存数据，一块用来顺序存日志。当我们写入数据的时候，先把数据写到内存里积攒，这时候再把我们需要的东西写到顺序存的日志内存里，日志内存积攒到一定程序会顺序写入磁盘，写完以后再写数据。因为省掉了多次寻址的时间，顺序写的日志写得会比乱序写数据快，做到尽可能减少服务宕机的损失。<br>再回归数据库的写入过程。每一次写入，我们会有下面几步：</p><ol><li>从磁盘中读取目标页到内存</li><li>修改内存中的目标页数据</li><li>将目标页的数据刷新回磁盘</li></ol><p>由于IO的主要瓶颈在寻址，读取目标页也需要寻址，因此也需要花费IO时间。可以说，假如执行5个insert语句进行一次刷盘，这5个语句刚好都在不同页，对于数据来说，我们需要执行5次读取和5次写入，总共10次寻址。<br>再次回到本文最开头的分析，顺序IO速度快是因为它需要做的寻址次数少。所以，如果WAL日志能再减少一点寻址操作就好了。比如<strong>WAL不用读取目标页</strong>。事实上，大多数数据库也是这么做的。大部份时候，WAL并不会记录目标页的数据，只会记录你执行了什么操作。数据库里会读取原来的记录，进行操作，然后覆盖原来的记录。WAL的操作日志只会记录操作，并不关心原始记录是什么样子。这样进一步减少了寻址的时间。对于上面那个例子，执行5个insert语句进行一次刷盘，对于WAL来说只需要进行一次寻址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/21/WAL%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/"/>
    <url>/2023/08/21/WAL%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h4 id="概念介绍："><a href="#概念介绍：" class="headerlink" title="概念介绍："></a>概念介绍：</h4><ul><li>**XLOG           **            Transaction Log 事务日志，是一个统称</li><li><strong>WAL段文件</strong>               磁盘中存储XLOG的区块，数据按存储页的形式组织，每一页可能有多条XLOG数据</li><li><strong>XLOG record data</strong>  写在WAL段文件中的一条一条具体的数据， 含有日志序列号LSN Log Sequence Number</li></ul><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><h5 id="段文件的结构"><a href="#段文件的结构" class="headerlink" title="段文件的结构"></a>段文件的结构</h5><p>下图就是一个具体的WAL段文件区块，整个16MB的空间是存储分配给它的空间，这个段文件的大小可以通过参数调整，但默认为16MB。在段文件内部，空间会被按页划分，每一页时一个8KB的区块。这样当PostgreSQL系统读入WAL时就可以一页一页地读入了。每一页数据都包含了首部和数据部分。除了第一页的首部稍有不同外，其他的每一页都有相同的首部。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32610216/1686159058102-b114ade8-af27-4333-93d3-d38d9a42f61b.png#averageHue=%23f5f5f5&clientId=u9288eda9-28b4-4&from=paste&height=285&id=u85073801&originHeight=570&originWidth=1327&originalType=binary&ratio=2&rotation=0&showTitle=false&size=143980&status=done&style=none&taskId=u808a58f3-244d-4af1-84a6-d09dd0c21d5&title=&width=663.5" alt="image.png"><br>图1. WAL段文件的内部布局<br>下面是两种页面的首部结构。可以看到，首页的首部除了包含校验信息外，还记录了一些WAL的元数据。对于存储来说，元数据就是用来标记位置的信息，xlp_page_addr和xlp_rem_len就起到了这个作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>    uint16         xlp_magic;    /＊ 用于正确性检查的魔数 ＊/<br>    uint16         xlp_info;     /＊ 标记位 ＊/<br>    TimeLineID    xlp_tli;       /＊ 页面中第一条记录的时间线ID ＊/<br>    XLogRecPtr    xlp_pageaddr; /＊ 当前页面的XLOG地址 ＊/<br><br>    /＊ 当当前页面放不下一条完整记录时，我们会在下一个页面继续放，xlp_rem_len存储了先前页面<br>    ＊ 记录剩余的字节数。注意，xl_rem_len包含了备份区块的数据，也就是说它会在第一个首部跟踪<br>    ＊ xl_tot_len而不是xl_len。还要注意，延续的数据不一定是对齐的 ＊/<br>    uint32         xlp_rem_len;  /＊ 记录所有剩余数据的长度 ＊/<br>    &#125; XLogPageHeaderData;<br><br><span class="hljs-keyword">typedef</span> XLogPageHeaderData ＊XLogPageHeader;<br><br>/＊ 当设置了XLP_LONG_HEADER标记位时，我们将在页首部中存储额外的字段。<br>＊ (通常是在XLOG文件中的第一个页面中) 额外的字段用于确保文件的正确性 ＊/<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogLongPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>    XLogPageHeaderData <span class="hljs-built_in">std</span>;              /＊ 标准首部 ＊/<br>    uint64               xlp_sysid;       /＊ 来自pg_control中的系统标识符 ＊/<br>    uint32               xlp_seg_size;   /＊ 交叉校验 ＊/<br>    uint32               xlp_xlog_blcksz;/＊ 交叉校验 ＊/<br>    &#125; XLogLongPageHeaderData;<br></code></pre></td></tr></table></figure><h5 id="XLOG-record-data数据结构"><a href="#XLOG-record-data数据结构" class="headerlink" title="XLOG record data数据结构"></a>XLOG record data数据结构</h5><p>接下来聊聊XLOG record data是如何组织的。<br>每一个XLOG record data也有一个它自己的首部和它的数据部分。所有XLOG record data的首部结构都是相同的，它的数据结构是XLogRecord。它的结构如下，需要注意的是它包含了xl_xid事务标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogRecord</span></span><br><span class="hljs-class">&#123;</span><br>  uint32           xl_tot_len;   /＊ 整条记录的全长 ＊/<br>  TransactionId   xl_xid;        /＊ 事务ID ＊/<br>  uint32           xl_len;        /＊ 资源管理器的数据长度 ＊/<br>  uint8             xl_info;       /＊ 标记位，如下所示 ＊/<br>  RmgrId           xl_rmid;       /＊ 本记录的资源管理器 ＊/<br>  /＊ 这里有<span class="hljs-number">2B</span>的填充，初始化为<span class="hljs-number">0</span> ＊/<br>  XLogRecPtr       xl_prev;       /＊ 在日志中指向先前记录的指针 ＊/<br>  pg_crc32         xl_crc;        /＊ 本记录的CRC ＊/<br>&#125; XLogRecord;<br></code></pre></td></tr></table></figure><p>在PostgreSQL中，9.4和9.5是一个比较大的版本分界线，通用的首部，之后的数据部分前后版本不太一致，这里仅以9.4之前版本举例。对于9.5以后的版本，感兴趣的朋友可以去翻阅文档，这里就不再一一赘述了。<br>在9.4及以前版本，XLOG record data的数据部分有两种格式，分别是备份区块的格式和非备份区块的格式。插入介绍一下，PostgreSQL的WAL除了记录数据库进行的操作外，也会隔一段时间进行一次整页写入。这些整页写入就是备份区块，记录的操作就是非备份区块。<br>备份区块的数据结构如图所示，除了首部XLogRecord以外，还包含了BkpBlock和一个具体的页面。BkpBlock相当于数据库集簇里具体页面的元数据，包含了RelFileNode（即具体的关系的指针）、ForkNumber（指向是否是关系主体还是其他）文件内的区块号和页面空闲空间的信息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32610216/1686159887760-e2fbc00f-c86f-43cc-b6fb-a20fee138316.png#averageHue=%23eeeeee&clientId=u9288eda9-28b4-4&from=paste&height=380&id=u1b7c0899&originHeight=760&originWidth=1329&originalType=binary&ratio=2&rotation=0&showTitle=false&size=244854&status=done&style=none&taskId=u41338af3-4b56-4853-b924-b46bfd57d56&title=&width=664.5" alt="image.png"><br>        而在非备份区块中，数据结构会因操作而异，一条INSERT语句的XLOG记录由XlLogRecord结构体、xl_heap_insert结构和被插入的元组组成。xl_heap_insert用于定位插入位置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
